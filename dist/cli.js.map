{"version":3,"sources":["../node_modules/tsup/assets/esm_shims.js","../src/lib/url-parser.ts","../src/lib/config.ts","../src/lib/registry.ts","../src/lib/git.ts","../src/commands/add.ts","../src/commands/list.ts","../src/commands/rm.ts","../src/lib/scan.ts","../src/commands/sync.ts","../src/commands/browse.ts","../src/cli.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import type { ParsedGitUrl } from \"../types/index.js\";\n\n/**\n * Parse a Git URL (SSH or HTTPS) into its components\n *\n * Supports:\n * - SSH: git@github.com:owner/repo.git\n * - HTTPS: https://github.com/owner/repo.git\n * - HTTPS without .git: https://github.com/owner/repo\n */\nexport function parseGitUrl(url: string): ParsedGitUrl {\n  // Normalize: trim whitespace\n  url = url.trim();\n\n  // SSH format: git@host:owner/repo.git\n  const sshMatch = url.match(/^git@([^:]+):([^/]+)\\/(.+?)(?:\\.git)?$/);\n  if (sshMatch) {\n    const [, host, owner, repo] = sshMatch;\n    return {\n      host,\n      owner,\n      repo,\n      cloneUrl: url.endsWith(\".git\") ? url : `${url}.git`,\n    };\n  }\n\n  // HTTPS format: https://host/owner/repo.git\n  const httpsMatch = url.match(\n    /^https?:\\/\\/([^/]+)\\/([^/]+)\\/(.+?)(?:\\.git)?$/\n  );\n  if (httpsMatch) {\n    const [, host, owner, repo] = httpsMatch;\n    return {\n      host,\n      owner,\n      repo,\n      cloneUrl: url.endsWith(\".git\") ? url : `${url}.git`,\n    };\n  }\n\n  throw new Error(\n    `Invalid Git URL format: ${url}\\n` +\n      `Expected SSH (git@host:owner/repo.git) or HTTPS (https://host/owner/repo.git)`\n  );\n}\n\n/**\n * Generate a unique ID for a repository\n * Format: host:owner/repo\n */\nexport function generateRepoId(parsed: ParsedGitUrl): string {\n  return `${parsed.host}:${parsed.owner}/${parsed.repo}`;\n}\n\n/**\n * Validate that a string looks like a Git URL\n */\nexport function isValidGitUrl(url: string): boolean {\n  try {\n    parseGitUrl(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { homedir } from \"node:os\";\nimport { join } from \"node:path\";\nimport { mkdir } from \"node:fs/promises\";\n\n/**\n * Get the clones directory from environment or default to ~/Clones\n */\nexport function getClonesDir(): string {\n  return process.env.CLONES_DIR || join(homedir(), \"Clones\");\n}\n\n/**\n * Get the path to registry.json\n */\nexport function getRegistryPath(): string {\n  return join(getClonesDir(), \"registry.json\");\n}\n\n/**\n * Get the local path for a repository based on owner/repo\n */\nexport function getRepoPath(owner: string, repo: string): string {\n  return join(getClonesDir(), owner, repo);\n}\n\n/**\n * Ensure the clones directory exists\n */\nexport async function ensureClonesDir(): Promise<void> {\n  const dir = getClonesDir();\n  await mkdir(dir, { recursive: true });\n}\n\n/**\n * Default values for new registry entries\n */\nexport const DEFAULTS = {\n  updateStrategy: \"hard-reset\" as const,\n  submodules: \"none\" as const,\n  lfs: \"auto\" as const,\n  defaultRemoteName: \"origin\",\n};\n","import { readFile, writeFile, rename } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { dirname, join } from \"node:path\";\nimport { randomUUID } from \"node:crypto\";\nimport type { Registry, RegistryEntry } from \"../types/index.js\";\nimport { getRegistryPath, ensureClonesDir } from \"./config.js\";\n\n/**\n * Create an empty registry\n */\nexport function createEmptyRegistry(): Registry {\n  return {\n    version: \"1.0.0\",\n    lastUpdated: new Date().toISOString(),\n    repos: [],\n  };\n}\n\n/**\n * Read the registry from disk\n * Returns an empty registry if the file doesn't exist\n */\nexport async function readRegistry(): Promise<Registry> {\n  const path = getRegistryPath();\n\n  if (!existsSync(path)) {\n    return createEmptyRegistry();\n  }\n\n  try {\n    const content = await readFile(path, \"utf-8\");\n    const data = JSON.parse(content) as Registry;\n\n    // Validate basic structure\n    if (!data.version || !Array.isArray(data.repos)) {\n      throw new Error(\"Invalid registry format\");\n    }\n\n    return data;\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      throw new Error(`Registry file is corrupted: ${path}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Write the registry to disk atomically\n * Uses write-to-temp + rename pattern to prevent corruption\n */\nexport async function writeRegistry(registry: Registry): Promise<void> {\n  await ensureClonesDir();\n\n  const path = getRegistryPath();\n  const tempPath = join(dirname(path), `.registry.${randomUUID()}.tmp`);\n\n  // Update timestamp\n  registry.lastUpdated = new Date().toISOString();\n\n  // Write to temp file\n  const content = JSON.stringify(registry, null, 2);\n  await writeFile(tempPath, content, \"utf-8\");\n\n  // Atomic rename\n  await rename(tempPath, path);\n}\n\n/**\n * Find a registry entry by ID\n */\nexport function findEntry(registry: Registry, id: string): RegistryEntry | undefined {\n  return registry.repos.find((entry) => entry.id === id);\n}\n\n/**\n * Find a registry entry by owner/repo\n */\nexport function findEntryByOwnerRepo(\n  registry: Registry,\n  owner: string,\n  repo: string\n): RegistryEntry | undefined {\n  return registry.repos.find(\n    (entry) => entry.owner === owner && entry.repo === repo\n  );\n}\n\n/**\n * Add an entry to the registry\n * Throws if an entry with the same ID already exists\n */\nexport function addEntry(registry: Registry, entry: RegistryEntry): Registry {\n  if (findEntry(registry, entry.id)) {\n    throw new Error(`Repository already exists in registry: ${entry.id}`);\n  }\n\n  return {\n    ...registry,\n    repos: [...registry.repos, entry],\n  };\n}\n\n/**\n * Update an entry in the registry\n */\nexport function updateEntry(\n  registry: Registry,\n  id: string,\n  updates: Partial<RegistryEntry>\n): Registry {\n  const index = registry.repos.findIndex((entry) => entry.id === id);\n  if (index === -1) {\n    throw new Error(`Repository not found in registry: ${id}`);\n  }\n\n  const updatedRepos = [...registry.repos];\n  updatedRepos[index] = { ...updatedRepos[index], ...updates };\n\n  return {\n    ...registry,\n    repos: updatedRepos,\n  };\n}\n\n/**\n * Remove an entry from the registry\n */\nexport function removeEntry(registry: Registry, id: string): Registry {\n  const filtered = registry.repos.filter((entry) => entry.id !== id);\n\n  if (filtered.length === registry.repos.length) {\n    throw new Error(`Repository not found in registry: ${id}`);\n  }\n\n  return {\n    ...registry,\n    repos: filtered,\n  };\n}\n\n/**\n * Filter entries by tags (any match)\n */\nexport function filterByTags(\n  registry: Registry,\n  tags: string[]\n): RegistryEntry[] {\n  if (tags.length === 0) return registry.repos;\n\n  return registry.repos.filter((entry) =>\n    entry.tags?.some((tag) => tags.includes(tag))\n  );\n}\n\n/**\n * Filter entries by owner/repo pattern (supports wildcards)\n * Pattern format: \"owner/repo\" or \"owner/\\*\" or \"\\*\\/repo\"\n */\nexport function filterByPattern(\n  registry: Registry,\n  pattern: string\n): RegistryEntry[] {\n  const [ownerPattern, repoPattern] = pattern.split(\"/\");\n\n  return registry.repos.filter((entry) => {\n    const ownerMatch =\n      ownerPattern === \"*\" || entry.owner === ownerPattern;\n    const repoMatch =\n      !repoPattern || repoPattern === \"*\" || entry.repo === repoPattern;\n    return ownerMatch && repoMatch;\n  });\n}\n","import { simpleGit, type SimpleGit, type StatusResult } from \"simple-git\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport type { RepoStatus } from \"../types/index.js\";\n\n/**\n * Clone a repository to a local path\n */\nexport async function cloneRepo(\n  url: string,\n  localPath: string,\n  options: { remoteName?: string } = {}\n): Promise<void> {\n  const git = simpleGit();\n  const remoteName = options.remoteName || \"origin\";\n\n  await git.clone(url, localPath, [\"--origin\", remoteName]);\n}\n\n/**\n * Fetch from remote with prune\n */\nexport async function fetchWithPrune(\n  localPath: string,\n  remoteName: string = \"origin\"\n): Promise<void> {\n  const git = simpleGit(localPath);\n  await git.fetch(remoteName, [\"--prune\"]);\n}\n\n/**\n * Reset to upstream tracking branch (hard reset)\n */\nexport async function resetHard(localPath: string): Promise<number> {\n  const git = simpleGit(localPath);\n\n  // Get current position before reset\n  const beforeLog = await git.log({ maxCount: 1 });\n  const beforeHash = beforeLog.latest?.hash;\n\n  // Reset to upstream\n  await git.reset([\"--hard\", \"@{u}\"]);\n\n  // Get new position after reset\n  const afterLog = await git.log({ maxCount: 1 });\n  const afterHash = afterLog.latest?.hash;\n\n  // Count commits between old and new position\n  if (beforeHash && afterHash && beforeHash !== afterHash) {\n    try {\n      const log = await git.log({ from: beforeHash, to: afterHash });\n      return log.total;\n    } catch {\n      // If we can't count (e.g., history rewrite), return -1\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Pull with fast-forward only\n */\nexport async function pullFastForward(localPath: string): Promise<number> {\n  const git = simpleGit(localPath);\n\n  const beforeLog = await git.log({ maxCount: 1 });\n  const beforeHash = beforeLog.latest?.hash;\n\n  await git.pull([\"--ff-only\"]);\n\n  const afterLog = await git.log({ maxCount: 1 });\n  const afterHash = afterLog.latest?.hash;\n\n  if (beforeHash && afterHash && beforeHash !== afterHash) {\n    try {\n      const log = await git.log({ from: beforeHash, to: afterHash });\n      return log.total;\n    } catch {\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Update submodules recursively\n */\nexport async function updateSubmodules(localPath: string): Promise<void> {\n  const git = simpleGit(localPath);\n  await git.submoduleUpdate([\"--init\", \"--recursive\"]);\n}\n\n/**\n * Get the status of a local repository\n */\nexport async function getRepoStatus(localPath: string): Promise<RepoStatus> {\n  // Check if directory exists\n  if (!existsSync(localPath)) {\n    return {\n      exists: false,\n      isGitRepo: false,\n      currentBranch: null,\n      isDetached: false,\n      tracking: null,\n      ahead: 0,\n      behind: 0,\n      isDirty: false,\n    };\n  }\n\n  // Check if it's a git repo\n  if (!existsSync(join(localPath, \".git\"))) {\n    return {\n      exists: true,\n      isGitRepo: false,\n      currentBranch: null,\n      isDetached: false,\n      tracking: null,\n      ahead: 0,\n      behind: 0,\n      isDirty: false,\n    };\n  }\n\n  const git = simpleGit(localPath);\n\n  try {\n    const status: StatusResult = await git.status();\n\n    return {\n      exists: true,\n      isGitRepo: true,\n      currentBranch: status.current,\n      isDetached: status.detached,\n      tracking: status.tracking,\n      ahead: status.ahead,\n      behind: status.behind,\n      isDirty: status.files.length > 0,\n    };\n  } catch (error) {\n    // Corrupted git repo\n    return {\n      exists: true,\n      isGitRepo: false,\n      currentBranch: null,\n      isDetached: false,\n      tracking: null,\n      ahead: 0,\n      behind: 0,\n      isDirty: false,\n    };\n  }\n}\n\n/**\n * Get the remote URL for a repository\n */\nexport async function getRemoteUrl(\n  localPath: string,\n  remoteName: string = \"origin\"\n): Promise<string | null> {\n  const git = simpleGit(localPath);\n\n  try {\n    const remotes = await git.getRemotes(true);\n    const remote = remotes.find((r) => r.name === remoteName);\n    return remote?.refs?.fetch || null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check if a repository uses LFS (by checking .gitattributes)\n */\nexport async function usesLfs(localPath: string): Promise<boolean> {\n  const gitattributes = join(localPath, \".gitattributes\");\n  if (!existsSync(gitattributes)) {\n    return false;\n  }\n\n  try {\n    const { readFile } = await import(\"node:fs/promises\");\n    const content = await readFile(gitattributes, \"utf-8\");\n    return content.includes(\"filter=lfs\");\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Pull LFS objects\n */\nexport async function pullLfs(\n  localPath: string,\n  remoteName: string = \"origin\"\n): Promise<void> {\n  const git = simpleGit(localPath);\n  await git.raw([\"lfs\", \"pull\", remoteName]);\n}\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport { parseGitUrl, generateRepoId } from \"../lib/url-parser.js\";\nimport { readRegistry, writeRegistry, addEntry, findEntry } from \"../lib/registry.js\";\nimport { cloneRepo, getRepoStatus } from \"../lib/git.js\";\nimport { getRepoPath, DEFAULTS, ensureClonesDir } from \"../lib/config.js\";\nimport type { RegistryEntry } from \"../types/index.js\";\n\nexport default defineCommand({\n  meta: {\n    name: \"add\",\n    description: \"Add a new clone by Git URL\",\n  },\n  args: {\n    url: {\n      type: \"positional\",\n      description: \"Git URL (HTTPS or SSH)\",\n      required: true,\n    },\n    tags: {\n      type: \"string\",\n      description: \"Comma-separated tags\",\n    },\n    description: {\n      type: \"string\",\n      description: \"Human-readable description\",\n    },\n    \"update-strategy\": {\n      type: \"string\",\n      description: \"Update strategy: hard-reset (default) or ff-only\",\n    },\n    submodules: {\n      type: \"string\",\n      description: \"Submodule handling: none (default) or recursive\",\n    },\n    lfs: {\n      type: \"string\",\n      description: \"LFS handling: auto (default), always, or never\",\n    },\n  },\n  async run({ args }) {\n    p.intro(\"clones add\");\n\n    let spinnerStarted = false;\n    const s = p.spinner();\n\n    try {\n      // Parse the URL\n      const parsed = parseGitUrl(args.url);\n      const repoId = generateRepoId(parsed);\n      const localPath = getRepoPath(parsed.owner, parsed.repo);\n\n      p.log.info(`Repository: ${parsed.owner}/${parsed.repo}`);\n      p.log.info(`Host: ${parsed.host}`);\n\n      // Read current registry\n      const registry = await readRegistry();\n\n      // Check if already in registry\n      if (findEntry(registry, repoId)) {\n        p.log.error(`Repository already exists in registry: ${repoId}`);\n        p.log.info(\"Use 'clones update' to sync it, or 'clones rm' to remove it first.\");\n        process.exit(1);\n      }\n\n      // Check if local directory already exists\n      const status = await getRepoStatus(localPath);\n      if (status.exists) {\n        p.log.error(`Local directory already exists: ${localPath}`);\n        p.log.info(\"Use 'clones adopt' to add existing repos to the registry.\");\n        process.exit(1);\n      }\n\n      // Ensure clones directory exists\n      await ensureClonesDir();\n\n      // Clone the repository\n      s.start(`Cloning ${parsed.owner}/${parsed.repo}...`);\n      spinnerStarted = true;\n      await cloneRepo(parsed.cloneUrl, localPath);\n      s.stop(`Cloned to ${localPath}`);\n\n      // Parse options\n      const tags = args.tags\n        ? args.tags.split(\",\").map((t: string) => t.trim())\n        : undefined;\n\n      const updateStrategy =\n        args[\"update-strategy\"] === \"ff-only\" ? \"ff-only\" : DEFAULTS.updateStrategy;\n\n      const submodules =\n        args.submodules === \"recursive\" ? \"recursive\" : DEFAULTS.submodules;\n\n      const lfs =\n        args.lfs === \"always\"\n          ? \"always\"\n          : args.lfs === \"never\"\n          ? \"never\"\n          : DEFAULTS.lfs;\n\n      // Create registry entry\n      const entry: RegistryEntry = {\n        id: repoId,\n        host: parsed.host,\n        owner: parsed.owner,\n        repo: parsed.repo,\n        cloneUrl: parsed.cloneUrl,\n        description: args.description,\n        tags,\n        defaultRemoteName: DEFAULTS.defaultRemoteName,\n        updateStrategy,\n        submodules,\n        lfs,\n        addedAt: new Date().toISOString(),\n        addedBy: \"manual\",\n        lastSyncedAt: new Date().toISOString(),\n        managed: true,\n      };\n\n      // Add to registry\n      const updatedRegistry = addEntry(registry, entry);\n      await writeRegistry(updatedRegistry);\n\n      p.log.success(`Added ${parsed.owner}/${parsed.repo} to registry`);\n\n      if (tags && tags.length > 0) {\n        p.log.info(`Tags: ${tags.join(\", \")}`);\n      }\n\n      p.outro(\"Done!\");\n    } catch (error) {\n      if (spinnerStarted) {\n        s.stop(\"Failed\");\n      }\n      p.log.error(error instanceof Error ? error.message : String(error));\n      process.exit(1);\n    }\n  },\n});\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport { readRegistry, filterByTags, filterByPattern } from \"../lib/registry.js\";\nimport { getRepoStatus } from \"../lib/git.js\";\nimport { getRepoPath, getClonesDir } from \"../lib/config.js\";\nimport type { RegistryEntry, RepoStatus } from \"../types/index.js\";\n\ninterface ListItem {\n  entry: RegistryEntry;\n  status: RepoStatus;\n  localPath: string;\n}\n\nexport default defineCommand({\n  meta: {\n    name: \"list\",\n    description: \"List all tracked repositories\",\n  },\n  args: {\n    json: {\n      type: \"boolean\",\n      description: \"Output as JSON\",\n    },\n    tags: {\n      type: \"string\",\n      description: \"Filter by tags (comma-separated)\",\n    },\n    filter: {\n      type: \"string\",\n      description: \"Filter by owner/repo pattern (supports wildcards)\",\n    },\n  },\n  async run({ args }) {\n    const registry = await readRegistry();\n\n    if (registry.repos.length === 0) {\n      if (args.json) {\n        console.log(JSON.stringify({ version: \"1.0.0\", repos: [] }, null, 2));\n      } else {\n        p.log.info(\"No repositories in registry.\");\n        p.log.info(\"Use 'clones add <url>' to add a repository.\");\n      }\n      return;\n    }\n\n    // Apply filters\n    let repos = registry.repos;\n\n    if (args.tags) {\n      const tags = args.tags.split(\",\").map((t: string) => t.trim());\n      repos = filterByTags(registry, tags);\n    }\n\n    if (args.filter) {\n      const filtered = filterByPattern(\n        { ...registry, repos },\n        args.filter\n      );\n      repos = filtered;\n    }\n\n    if (repos.length === 0) {\n      if (args.json) {\n        console.log(JSON.stringify({ version: \"1.0.0\", repos: [] }, null, 2));\n      } else {\n        p.log.info(\"No repositories match the filter.\");\n      }\n      return;\n    }\n\n    // Gather status for each repo\n    const items: ListItem[] = await Promise.all(\n      repos.map(async (entry) => {\n        const localPath = getRepoPath(entry.owner, entry.repo);\n        const status = await getRepoStatus(localPath);\n        return { entry, status, localPath };\n      })\n    );\n\n    if (args.json) {\n      outputJson(items);\n    } else {\n      outputPretty(items, registry.lastUpdated);\n    }\n  },\n});\n\nfunction outputJson(items: ListItem[]): void {\n  const output = {\n    version: \"1.0.0\",\n    repos: items.map(({ entry, status, localPath }) => ({\n      id: entry.id,\n      owner: entry.owner,\n      repo: entry.repo,\n      localPath,\n      cloneUrl: entry.cloneUrl,\n      branch: status.currentBranch,\n      tracking: status.tracking,\n      behindCount: status.behind,\n      aheadCount: status.ahead,\n      isDirty: status.isDirty,\n      isDetached: status.isDetached,\n      hasUpstream: !!status.tracking,\n      exists: status.exists,\n      isGitRepo: status.isGitRepo,\n      lastSyncedAt: entry.lastSyncedAt,\n      tags: entry.tags,\n      description: entry.description,\n    })),\n  };\n\n  console.log(JSON.stringify(output, null, 2));\n}\n\nfunction outputPretty(items: ListItem[], lastUpdated: string): void {\n  const clonesDir = getClonesDir();\n  const shortDir = clonesDir.replace(process.env.HOME || \"\", \"~\");\n\n  console.log();\n  console.log(\n    `Clones Registry (${items.length} repos, last updated ${formatDate(lastUpdated)})`\n  );\n  console.log();\n\n  for (const { entry, status, localPath } of items) {\n    const shortPath = localPath.replace(process.env.HOME || \"\", \"~\");\n\n    console.log(`${entry.owner}/${entry.repo}`);\n    console.log(`  Path: ${shortPath}`);\n    console.log(`  URL: ${entry.cloneUrl}`);\n\n    if (entry.tags && entry.tags.length > 0) {\n      console.log(`  Tags: ${entry.tags.join(\", \")}`);\n    }\n\n    if (entry.description) {\n      console.log(`  Description: ${entry.description}`);\n    }\n\n    // Status line\n    if (!status.exists) {\n      console.log(`  Status: \\u2717 Missing (not cloned)`);\n    } else if (!status.isGitRepo) {\n      console.log(`  Status: \\u2717 Not a Git repository`);\n    } else if (status.isDetached) {\n      console.log(`  Branch: (detached HEAD)`);\n      console.log(`  Status: \\u26A0 Detached HEAD`);\n    } else if (!status.tracking) {\n      console.log(`  Branch: ${status.currentBranch} (no upstream)`);\n      console.log(`  Status: \\u26A0 No upstream tracking`);\n    } else {\n      const syncStatus = getSyncStatus(status, entry.lastSyncedAt);\n      console.log(`  Branch: ${status.currentBranch} \\u2192 ${status.tracking}`);\n      console.log(`  Status: ${syncStatus}`);\n    }\n\n    console.log();\n  }\n}\n\nfunction getSyncStatus(status: RepoStatus, lastSyncedAt?: string): string {\n  const parts: string[] = [];\n\n  if (status.isDirty) {\n    parts.push(\"\\u2717 Dirty\");\n  }\n\n  if (status.behind > 0) {\n    parts.push(`${status.behind} behind`);\n  }\n\n  if (status.ahead > 0) {\n    parts.push(`${status.ahead} ahead`);\n  }\n\n  if (parts.length === 0) {\n    parts.push(\"\\u2713 Clean\");\n  }\n\n  if (lastSyncedAt) {\n    parts.push(`(synced ${formatRelativeTime(lastSyncedAt)})`);\n  }\n\n  return parts.join(\", \");\n}\n\nfunction formatDate(isoString: string): string {\n  const date = new Date(isoString);\n  return date.toLocaleDateString(\"en-US\", {\n    year: \"numeric\",\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n  });\n}\n\nfunction formatRelativeTime(isoString: string): string {\n  const date = new Date(isoString);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMins / 60);\n  const diffDays = Math.floor(diffHours / 24);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 30) return `${diffDays}d ago`;\n  return formatDate(isoString);\n}\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport { rm } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { readRegistry, writeRegistry, removeEntry, findEntryByOwnerRepo } from \"../lib/registry.js\";\nimport { getRepoPath } from \"../lib/config.js\";\n\nexport default defineCommand({\n  meta: {\n    name: \"rm\",\n    description: \"Remove a repository from the registry (and optionally from disk)\",\n  },\n  args: {\n    repo: {\n      type: \"positional\",\n      description: \"Repository identifier (owner/repo)\",\n      required: true,\n    },\n    \"keep-disk\": {\n      type: \"boolean\",\n      description: \"Keep the local directory (only remove from registry)\",\n      default: false,\n    },\n    yes: {\n      type: \"boolean\",\n      alias: \"y\",\n      description: \"Skip confirmation prompt\",\n      default: false,\n    },\n  },\n  async run({ args }) {\n    p.intro(\"clones rm\");\n\n    // Parse owner/repo from argument\n    const parts = args.repo.split(\"/\");\n    if (parts.length !== 2) {\n      p.log.error(`Invalid format: ${args.repo}`);\n      p.log.info(\"Expected format: owner/repo\");\n      process.exit(1);\n    }\n\n    const [owner, repo] = parts;\n\n    // Load registry\n    const registry = await readRegistry();\n\n    // Find entry\n    const entry = findEntryByOwnerRepo(registry, owner, repo);\n\n    if (!entry) {\n      p.log.error(`Repository not found in registry: ${owner}/${repo}`);\n      p.log.info(\"Use 'clones list' to see all tracked repositories.\");\n      process.exit(1);\n    }\n\n    // Check if local directory exists\n    const localPath = getRepoPath(owner, repo);\n    const diskExists = existsSync(localPath);\n\n    // Show what will happen\n    p.log.info(`Repository: ${owner}/${repo}`);\n    p.log.info(`Registry ID: ${entry.id}`);\n    p.log.info(`Local path: ${localPath}`);\n    p.log.info(`On disk: ${diskExists ? \"Yes\" : \"No (already deleted)\"}`);\n\n    // Determine actions\n    const willDeleteFromRegistry = true;\n    const willDeleteFromDisk = diskExists && !args[\"keep-disk\"];\n\n    p.log.step(\"\\nActions to perform:\");\n    p.log.message(`   ✓ Remove from registry`);\n    if (willDeleteFromDisk) {\n      p.log.message(`   ✓ Delete local directory`);\n    } else if (diskExists && args[\"keep-disk\"]) {\n      p.log.message(`   ○ Keep local directory (--keep-disk)`);\n    } else if (!diskExists) {\n      p.log.message(`   ○ Local directory doesn't exist`);\n    }\n\n    // Confirm\n    if (!args.yes) {\n      const message = willDeleteFromDisk\n        ? `Remove ${owner}/${repo} from registry AND delete from disk?`\n        : `Remove ${owner}/${repo} from registry?`;\n\n      const shouldContinue = await p.confirm({\n        message,\n      });\n\n      if (p.isCancel(shouldContinue) || !shouldContinue) {\n        p.outro(\"Cancelled\");\n        return;\n      }\n    }\n\n    // Delete from disk first (if needed)\n    if (willDeleteFromDisk) {\n      const s = p.spinner();\n      s.start(`Deleting ${localPath}...`);\n\n      try {\n        await rm(localPath, { recursive: true, force: true });\n        s.stop(`Deleted ${localPath}`);\n      } catch (error) {\n        s.stop(\"Failed to delete directory\");\n        p.log.error(error instanceof Error ? error.message : String(error));\n        p.log.info(\"Registry entry was NOT removed. Fix the issue and try again.\");\n        process.exit(1);\n      }\n    }\n\n    // Remove from registry\n    try {\n      const updatedRegistry = removeEntry(registry, entry.id);\n      await writeRegistry(updatedRegistry);\n      p.log.success(`Removed ${owner}/${repo} from registry`);\n    } catch (error) {\n      p.log.error(error instanceof Error ? error.message : String(error));\n      process.exit(1);\n    }\n\n    p.outro(\"Done!\");\n  },\n});\n","import { readdir, stat, lstat } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport { existsSync } from \"node:fs\";\nimport { getClonesDir } from \"./config.js\";\n\n/**\n * Represents a discovered repository on disk\n */\nexport interface DiscoveredRepo {\n  owner: string;\n  repo: string;\n  localPath: string;\n  hasGit: boolean;\n}\n\n/**\n * Represents the result of scanning a potential repo location\n */\nexport interface ScanResult {\n  discovered: DiscoveredRepo[];\n  skipped: { path: string; reason: string }[];\n}\n\n/**\n * Check if a path is a symlink\n */\nasync function isSymlink(path: string): Promise<boolean> {\n  try {\n    const stats = await lstat(path);\n    return stats.isSymbolicLink();\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if a path is a directory (following symlinks)\n */\nasync function isDirectory(path: string): Promise<boolean> {\n  try {\n    const stats = await stat(path);\n    return stats.isDirectory();\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Scan the clones directory for repositories at depth 2\n * Expects structure: $CLONES_DIR/owner/repo/.git\n */\nexport async function scanClonesDir(): Promise<ScanResult> {\n  const clonesDir = getClonesDir();\n  const discovered: DiscoveredRepo[] = [];\n  const skipped: { path: string; reason: string }[] = [];\n\n  // Ensure clones dir exists\n  if (!existsSync(clonesDir)) {\n    return { discovered, skipped };\n  }\n\n  // List owner directories (depth 1)\n  let ownerDirs: string[];\n  try {\n    ownerDirs = await readdir(clonesDir);\n  } catch (error) {\n    skipped.push({\n      path: clonesDir,\n      reason: `Cannot read directory: ${error instanceof Error ? error.message : String(error)}`,\n    });\n    return { discovered, skipped };\n  }\n\n  for (const owner of ownerDirs) {\n    // Skip hidden files and registry.json\n    if (owner.startsWith(\".\") || owner === \"registry.json\") {\n      continue;\n    }\n\n    const ownerPath = join(clonesDir, owner);\n\n    // Skip symlinks at owner level\n    if (await isSymlink(ownerPath)) {\n      skipped.push({ path: ownerPath, reason: \"Symlink (skipped)\" });\n      continue;\n    }\n\n    // Skip non-directories\n    if (!(await isDirectory(ownerPath))) {\n      continue;\n    }\n\n    // List repo directories (depth 2)\n    let repoDirs: string[];\n    try {\n      repoDirs = await readdir(ownerPath);\n    } catch (error) {\n      skipped.push({\n        path: ownerPath,\n        reason: `Cannot read directory: ${error instanceof Error ? error.message : String(error)}`,\n      });\n      continue;\n    }\n\n    for (const repo of repoDirs) {\n      // Skip hidden directories\n      if (repo.startsWith(\".\")) {\n        continue;\n      }\n\n      const repoPath = join(ownerPath, repo);\n\n      // Skip symlinks at repo level\n      if (await isSymlink(repoPath)) {\n        skipped.push({ path: repoPath, reason: \"Symlink (skipped)\" });\n        continue;\n      }\n\n      // Skip non-directories\n      if (!(await isDirectory(repoPath))) {\n        continue;\n      }\n\n      // Check for .git directory\n      const gitPath = join(repoPath, \".git\");\n      const hasGit = existsSync(gitPath);\n\n      if (!hasGit) {\n        skipped.push({ path: repoPath, reason: \"No .git directory\" });\n        continue;\n      }\n\n      discovered.push({\n        owner,\n        repo,\n        localPath: repoPath,\n        hasGit: true,\n      });\n    }\n  }\n\n  return { discovered, skipped };\n}\n\n/**\n * Check if a repo appears to be a submodule or worktree (nested repo)\n * A submodule has a .git file (not directory) pointing elsewhere\n * A worktree has a .git file with \"gitdir:\" reference\n */\nexport async function isNestedRepo(localPath: string): Promise<boolean> {\n  const gitPath = join(localPath, \".git\");\n\n  try {\n    const stats = await lstat(gitPath);\n\n    // If .git is a file (not directory), it's likely a submodule or worktree\n    if (stats.isFile()) {\n      return true;\n    }\n\n    // Check for signs of being inside another repo\n    // Walk up to see if there's a parent .git\n    const clonesDir = getClonesDir();\n    let current = localPath;\n\n    while (current !== clonesDir && current !== \"/\") {\n      const parent = join(current, \"..\");\n      const parentGit = join(parent, \".git\");\n\n      if (existsSync(parentGit) && parent !== clonesDir) {\n        // There's a .git above us (but not at clones root)\n        return true;\n      }\n\n      current = parent;\n    }\n\n    return false;\n  } catch {\n    return false;\n  }\n}\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport {\n  readRegistry,\n  writeRegistry,\n  updateEntry,\n  addEntry,\n  filterByPattern,\n  findEntry,\n} from \"../lib/registry.js\";\nimport {\n  fetchWithPrune,\n  resetHard,\n  pullFastForward,\n  getRepoStatus,\n  updateSubmodules,\n  usesLfs,\n  pullLfs,\n  cloneRepo,\n  getRemoteUrl,\n} from \"../lib/git.js\";\nimport { getRepoPath, getClonesDir, DEFAULTS } from \"../lib/config.js\";\nimport { scanClonesDir, isNestedRepo } from \"../lib/scan.js\";\nimport { parseGitUrl, generateRepoId } from \"../lib/url-parser.js\";\nimport type { RegistryEntry, UpdateResult, Registry } from \"../types/index.js\";\n\ninterface UpdateSummary {\n  name: string;\n  action: \"adopted\" | \"cloned\" | \"updated\" | \"skipped\" | \"error\";\n  detail?: string;\n}\n\nexport default defineCommand({\n  meta: {\n    name: \"sync\",\n    description: \"Synchronize registry and clones (adopt, clone missing, fetch/reset)\",\n  },\n  args: {\n    filter: {\n      type: \"string\",\n      description: \"Filter by owner/repo pattern (supports wildcards)\",\n    },\n    \"dry-run\": {\n      type: \"boolean\",\n      description: \"Show what would happen without making changes\",\n    },\n    force: {\n      type: \"boolean\",\n      description: \"Proceed even if working tree is dirty\",\n    },\n  },\n  async run({ args }) {\n    p.intro(\"clones sync\");\n\n    const dryRun = args[\"dry-run\"] || false;\n    const force = args.force || false;\n\n    if (dryRun) {\n      p.log.warn(\"Dry run mode - no changes will be made\");\n    }\n\n    let registry = await readRegistry();\n    const summaries: UpdateSummary[] = [];\n\n    // ═══════════════════════════════════════════════════════════════════\n    // PHASE 1: ADOPT - Discover untracked repos on disk\n    // ═══════════════════════════════════════════════════════════════════\n    p.log.step(\"Phase 1: Discovering untracked repos...\");\n\n    const { adopted, registry: registryAfterAdopt } = await adoptPhase(\n      registry,\n      { dryRun }\n    );\n    registry = registryAfterAdopt;\n\n    for (const repo of adopted) {\n      summaries.push({\n        name: `${repo.owner}/${repo.repo}`,\n        action: \"adopted\",\n      });\n    }\n\n    if (adopted.length === 0) {\n      p.log.info(\"  No untracked repos found\");\n    } else {\n      p.log.success(`  ${adopted.length} repo(s) ${dryRun ? \"would be\" : \"\"} adopted`);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════\n    // PHASE 2: CLONE - Clone repos in registry but missing from disk\n    // ═══════════════════════════════════════════════════════════════════\n    p.log.step(\"Phase 2: Cloning missing repos...\");\n\n    const { cloned, errors: cloneErrors } = await clonePhase(registry, { dryRun });\n\n    for (const repo of cloned) {\n      summaries.push({\n        name: `${repo.owner}/${repo.repo}`,\n        action: \"cloned\",\n      });\n    }\n\n    for (const err of cloneErrors) {\n      summaries.push({\n        name: err.name,\n        action: \"error\",\n        detail: err.error,\n      });\n    }\n\n    if (cloned.length === 0 && cloneErrors.length === 0) {\n      p.log.info(\"  No missing repos to clone\");\n    } else {\n      if (cloned.length > 0) {\n        p.log.success(`  ${cloned.length} repo(s) ${dryRun ? \"would be\" : \"\"} cloned`);\n      }\n      if (cloneErrors.length > 0) {\n        p.log.error(`  ${cloneErrors.length} clone error(s)`);\n      }\n    }\n\n    // ═══════════════════════════════════════════════════════════════════\n    // PHASE 3: UPDATE - Fetch and reset all tracked repos\n    // ═══════════════════════════════════════════════════════════════════\n    p.log.step(\"Phase 3: Updating repos...\");\n\n    // Apply filter if specified\n    let reposToUpdate = registry.repos.filter((r) => r.managed);\n\n    if (args.filter) {\n      reposToUpdate = filterByPattern({ ...registry, repos: reposToUpdate }, args.filter);\n      p.log.info(`  Filtering to: ${args.filter}`);\n    }\n\n    if (reposToUpdate.length === 0) {\n      p.log.info(\"  No repos to update\");\n    } else {\n      for (const entry of reposToUpdate) {\n        const result = await updateRepo(entry, { dryRun, force });\n        const name = `${entry.owner}/${entry.repo}`;\n\n        if (result.status === \"updated\") {\n          summaries.push({\n            name,\n            action: \"updated\",\n            detail: result.commits ? `${result.commits} commits` : undefined,\n          });\n\n          // Update lastSyncedAt\n          if (!dryRun) {\n            registry = updateEntry(registry, entry.id, {\n              lastSyncedAt: new Date().toISOString(),\n            });\n          }\n        } else if (result.status === \"skipped\") {\n          summaries.push({\n            name,\n            action: \"skipped\",\n            detail: result.reason,\n          });\n        } else {\n          summaries.push({\n            name,\n            action: \"error\",\n            detail: result.error,\n          });\n        }\n      }\n    }\n\n    // ═══════════════════════════════════════════════════════════════════\n    // SAVE & SUMMARY\n    // ═══════════════════════════════════════════════════════════════════\n    if (!dryRun) {\n      await writeRegistry(registry);\n    }\n\n    console.log();\n    printSummary(summaries, dryRun);\n\n    p.outro(\"Done!\");\n  },\n});\n\n// ─────────────────────────────────────────────────────────────────────────────\n// PHASE 1: ADOPT\n// ─────────────────────────────────────────────────────────────────────────────\n\ninterface AdoptResult {\n  adopted: { owner: string; repo: string }[];\n  registry: Registry;\n}\n\nasync function adoptPhase(\n  registry: Registry,\n  options: { dryRun: boolean }\n): Promise<AdoptResult> {\n  const adopted: { owner: string; repo: string }[] = [];\n  let updatedRegistry = registry;\n\n  const { discovered } = await scanClonesDir();\n\n  for (const repo of discovered) {\n    // Check if already in registry\n    const existing = registry.repos.find(\n      (e) => e.owner === repo.owner && e.repo === repo.repo\n    );\n\n    if (existing) {\n      continue; // Already tracked\n    }\n\n    // Check if nested repo\n    if (await isNestedRepo(repo.localPath)) {\n      continue;\n    }\n\n    // Get remote URL\n    const remoteUrl = await getRemoteUrl(repo.localPath);\n    if (!remoteUrl) {\n      continue; // No origin remote\n    }\n\n    // Parse URL\n    let parsed;\n    try {\n      parsed = parseGitUrl(remoteUrl);\n    } catch {\n      continue; // Can't parse URL\n    }\n\n    const repoId = generateRepoId(parsed);\n\n    // Check if ID already exists (different owner/repo but same ID)\n    if (findEntry(updatedRegistry, repoId)) {\n      continue;\n    }\n\n    if (!options.dryRun) {\n      const entry: RegistryEntry = {\n        id: repoId,\n        host: parsed.host,\n        owner: parsed.owner,\n        repo: parsed.repo,\n        cloneUrl: parsed.cloneUrl,\n        defaultRemoteName: DEFAULTS.defaultRemoteName,\n        updateStrategy: DEFAULTS.updateStrategy,\n        submodules: DEFAULTS.submodules,\n        lfs: DEFAULTS.lfs,\n        addedAt: new Date().toISOString(),\n        addedBy: \"adopt\",\n        managed: true,\n      };\n\n      updatedRegistry = addEntry(updatedRegistry, entry);\n    }\n\n    adopted.push({ owner: repo.owner, repo: repo.repo });\n    p.log.info(`  + ${repo.owner}/${repo.repo}`);\n  }\n\n  return { adopted, registry: updatedRegistry };\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// PHASE 2: CLONE\n// ─────────────────────────────────────────────────────────────────────────────\n\ninterface CloneResult {\n  cloned: { owner: string; repo: string }[];\n  errors: { name: string; error: string }[];\n}\n\nasync function clonePhase(\n  registry: Registry,\n  options: { dryRun: boolean }\n): Promise<CloneResult> {\n  const cloned: { owner: string; repo: string }[] = [];\n  const errors: { name: string; error: string }[] = [];\n\n  for (const entry of registry.repos) {\n    if (!entry.managed) continue;\n\n    const localPath = getRepoPath(entry.owner, entry.repo);\n    const status = await getRepoStatus(localPath);\n\n    if (status.exists && status.isGitRepo) {\n      continue; // Already exists\n    }\n\n    const name = `${entry.owner}/${entry.repo}`;\n\n    if (options.dryRun) {\n      p.log.info(`  + ${name} (would clone)`);\n      cloned.push({ owner: entry.owner, repo: entry.repo });\n      continue;\n    }\n\n    // Clone the repo\n    const s = p.spinner();\n    s.start(`  Cloning ${name}...`);\n\n    try {\n      await cloneRepo(entry.cloneUrl, localPath, {\n        remoteName: entry.defaultRemoteName,\n      });\n      s.stop(`  + ${name} (cloned)`);\n      cloned.push({ owner: entry.owner, repo: entry.repo });\n    } catch (error) {\n      s.stop(`  ✗ ${name} (clone failed)`);\n      errors.push({\n        name,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  return { cloned, errors };\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// PHASE 3: UPDATE (existing logic, slightly refactored)\n// ─────────────────────────────────────────────────────────────────────────────\n\nasync function updateRepo(\n  entry: RegistryEntry,\n  options: { dryRun: boolean; force: boolean }\n): Promise<UpdateResult> {\n  const localPath = getRepoPath(entry.owner, entry.repo);\n  const repoName = `${entry.owner}/${entry.repo}`;\n\n  // Check status\n  const status = await getRepoStatus(localPath);\n\n  if (!status.exists) {\n    p.log.error(`  ✗ ${repoName} (missing)`);\n    return { status: \"skipped\", reason: \"directory missing\" };\n  }\n\n  if (!status.isGitRepo) {\n    p.log.error(`  ✗ ${repoName} (not a git repo)`);\n    return { status: \"skipped\", reason: \"not a git repo\" };\n  }\n\n  if (status.isDetached) {\n    p.log.warn(`  ○ ${repoName} (detached HEAD)`);\n    return { status: \"skipped\", reason: \"detached HEAD\" };\n  }\n\n  if (!status.tracking) {\n    p.log.warn(`  ○ ${repoName} (no upstream)`);\n    return { status: \"skipped\", reason: \"no upstream tracking\" };\n  }\n\n  if (status.isDirty && !options.force) {\n    p.log.warn(`  ○ ${repoName} (dirty, use --force)`);\n    return { status: \"skipped\", reason: \"dirty working tree\" };\n  }\n\n  if (options.dryRun) {\n    p.log.info(`  ✓ ${repoName} (would update)`);\n    return { status: \"updated\", commits: 0 };\n  }\n\n  try {\n    // Fetch\n    const s = p.spinner();\n    s.start(`  ${repoName}: fetching...`);\n    await fetchWithPrune(localPath, entry.defaultRemoteName);\n\n    // Reset or pull based on strategy\n    let commits = 0;\n    if (entry.updateStrategy === \"hard-reset\") {\n      commits = await resetHard(localPath);\n      s.stop(`  ✓ ${repoName} (reset${commits > 0 ? `, ${commits} commits` : \"\"})`);\n    } else {\n      commits = await pullFastForward(localPath);\n      s.stop(`  ✓ ${repoName} (ff-only${commits > 0 ? `, ${commits} commits` : \"\"})`);\n    }\n\n    // Submodules\n    if (entry.submodules === \"recursive\") {\n      try {\n        await updateSubmodules(localPath);\n      } catch {\n        // Silent fail for submodules\n      }\n    }\n\n    // LFS\n    if (entry.lfs === \"always\" || (entry.lfs === \"auto\" && (await usesLfs(localPath)))) {\n      try {\n        await pullLfs(localPath, entry.defaultRemoteName);\n      } catch {\n        // Silent fail for LFS\n      }\n    }\n\n    return { status: \"updated\", commits };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    p.log.error(`  ✗ ${repoName}: ${message}`);\n    return { status: \"error\", error: message };\n  }\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// SUMMARY\n// ─────────────────────────────────────────────────────────────────────────────\n\nfunction printSummary(summaries: UpdateSummary[], dryRun: boolean): void {\n  const adopted = summaries.filter((s) => s.action === \"adopted\").length;\n  const cloned = summaries.filter((s) => s.action === \"cloned\").length;\n  const updated = summaries.filter((s) => s.action === \"updated\").length;\n  const skipped = summaries.filter((s) => s.action === \"skipped\").length;\n  const errors = summaries.filter((s) => s.action === \"error\").length;\n\n  console.log(\"─\".repeat(50));\n\n  if (dryRun) {\n    console.log(\"Would:\");\n  }\n\n  const parts: string[] = [];\n  if (adopted > 0) parts.push(`${adopted} adopted`);\n  if (cloned > 0) parts.push(`${cloned} cloned`);\n  if (updated > 0) parts.push(`${updated} updated`);\n  if (skipped > 0) parts.push(`${skipped} skipped`);\n  if (errors > 0) parts.push(`${errors} errors`);\n\n  if (parts.length === 0) {\n    console.log(\"Nothing to do.\");\n  } else {\n    console.log(parts.join(\", \"));\n  }\n}\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport { exec } from \"node:child_process\";\nimport { promisify } from \"node:util\";\nimport {\n  readRegistry,\n  writeRegistry,\n  updateEntry,\n} from \"../lib/registry.js\";\nimport { getRepoStatus } from \"../lib/git.js\";\nimport { getRepoPath } from \"../lib/config.js\";\nimport type { RegistryEntry, RepoStatus } from \"../types/index.js\";\n\nconst execAsync = promisify(exec);\n\ninterface RepoInfo {\n  entry: RegistryEntry;\n  status: RepoStatus;\n  localPath: string;\n}\n\nexport default defineCommand({\n  meta: {\n    name: \"browse\",\n    description: \"Interactively browse and manage clones\",\n  },\n  args: {},\n  async run() {\n    p.intro(\"clones\");\n\n    const registry = await readRegistry();\n\n    if (registry.repos.length === 0) {\n      p.log.info(\"No repositories in registry.\");\n      p.log.info(\"Use 'clones add <url>' to add a repository.\");\n      p.outro(\"\");\n      return;\n    }\n\n    // Gather status for all repos\n    const s = p.spinner();\n    s.start(\"Loading repositories...\");\n\n    const repos: RepoInfo[] = await Promise.all(\n      registry.repos.map(async (entry) => {\n        const localPath = getRepoPath(entry.owner, entry.repo);\n        const status = await getRepoStatus(localPath);\n        return { entry, status, localPath };\n      })\n    );\n\n    s.stop(`${repos.length} repositories loaded`);\n\n    // Build select options\n    const options = repos.map((repo) => {\n      const name = `${repo.entry.owner}/${repo.entry.repo}`;\n      const hints: string[] = [];\n\n      if (repo.entry.tags && repo.entry.tags.length > 0) {\n        hints.push(repo.entry.tags.join(\", \"));\n      }\n      if (!repo.status.exists) {\n        hints.push(\"missing\");\n      } else if (repo.status.isDirty) {\n        hints.push(\"dirty\");\n      }\n\n      return {\n        value: repo,\n        label: name,\n        hint: hints.length > 0 ? hints.join(\" · \") : undefined,\n      };\n    });\n\n    // Select a repository\n    const selected = await p.select({\n      message: \"Select a repository\",\n      options,\n    });\n\n    if (p.isCancel(selected)) {\n      p.outro(\"Cancelled\");\n      return;\n    }\n\n    const repo = selected as RepoInfo;\n    await showRepoDetails(repo, registry);\n  },\n});\n\nasync function showRepoDetails(\n  repo: RepoInfo,\n  registry: Awaited<ReturnType<typeof readRegistry>>\n): Promise<void> {\n  const shortPath = repo.localPath.replace(process.env.HOME || \"\", \"~\");\n\n  // Display repo info\n  console.log();\n  console.log(`  ${repo.entry.owner}/${repo.entry.repo}`);\n  console.log(`  ${\"─\".repeat(40)}`);\n  console.log(`  Path: ${shortPath}`);\n  console.log(`  URL:  ${repo.entry.cloneUrl}`);\n\n  if (repo.entry.tags && repo.entry.tags.length > 0) {\n    console.log(`  Tags: ${repo.entry.tags.join(\", \")}`);\n  } else {\n    console.log(`  Tags: (none)`);\n  }\n\n  if (repo.entry.description) {\n    console.log(`  Desc: ${repo.entry.description}`);\n  } else {\n    console.log(`  Desc: (none)`);\n  }\n\n  // Status\n  if (!repo.status.exists) {\n    console.log(`  Status: ✗ Missing`);\n  } else if (!repo.status.isGitRepo) {\n    console.log(`  Status: ✗ Not a git repo`);\n  } else if (repo.status.isDirty) {\n    console.log(`  Status: ● Dirty`);\n  } else {\n    console.log(`  Status: ✓ Clean`);\n  }\n\n  if (repo.entry.lastSyncedAt) {\n    console.log(`  Synced: ${formatRelativeTime(repo.entry.lastSyncedAt)}`);\n  }\n\n  console.log();\n\n  // Action menu\n  const action = await p.select({\n    message: \"What would you like to do?\",\n    options: [\n      { value: \"copy\", label: \"Copy path to clipboard\" },\n      { value: \"edit-tags\", label: \"Edit tags\" },\n      { value: \"edit-desc\", label: \"Edit description\" },\n      { value: \"back\", label: \"Back to list\" },\n    ],\n  });\n\n  if (p.isCancel(action)) {\n    p.outro(\"Done\");\n    return;\n  }\n\n  switch (action) {\n    case \"copy\":\n      await copyToClipboard(repo.localPath);\n      p.log.success(`Copied: ${repo.localPath}`);\n      p.outro(\"Done\");\n      break;\n\n    case \"edit-tags\":\n      await editTags(repo, registry);\n      break;\n\n    case \"edit-desc\":\n      await editDescription(repo, registry);\n      break;\n\n    case \"back\":\n      // Re-run the browse command (recursive)\n      const { default: browseCommand } = await import(\"./browse.js\");\n      await browseCommand.run?.({ args: {} } as any);\n      break;\n  }\n}\n\nasync function editTags(\n  repo: RepoInfo,\n  registry: Awaited<ReturnType<typeof readRegistry>>\n): Promise<void> {\n  const currentTags = repo.entry.tags?.join(\", \") || \"\";\n\n  const newTags = await p.text({\n    message: \"Enter tags (comma-separated)\",\n    initialValue: currentTags,\n    placeholder: \"cli, typescript, framework\",\n  });\n\n  if (p.isCancel(newTags)) {\n    p.outro(\"Cancelled\");\n    return;\n  }\n\n  const tags = newTags\n    ? newTags\n        .split(\",\")\n        .map((t) => t.trim())\n        .filter((t) => t.length > 0)\n    : undefined;\n\n  const updatedRegistry = updateEntry(registry, repo.entry.id, { tags });\n  await writeRegistry(updatedRegistry);\n\n  p.log.success(`Tags updated for ${repo.entry.owner}/${repo.entry.repo}`);\n  p.outro(\"Done\");\n}\n\nasync function editDescription(\n  repo: RepoInfo,\n  registry: Awaited<ReturnType<typeof readRegistry>>\n): Promise<void> {\n  const newDesc = await p.text({\n    message: \"Enter description\",\n    initialValue: repo.entry.description || \"\",\n    placeholder: \"A brief description of this repository\",\n  });\n\n  if (p.isCancel(newDesc)) {\n    p.outro(\"Cancelled\");\n    return;\n  }\n\n  const description = newDesc || undefined;\n\n  const updatedRegistry = updateEntry(registry, repo.entry.id, { description });\n  await writeRegistry(updatedRegistry);\n\n  p.log.success(`Description updated for ${repo.entry.owner}/${repo.entry.repo}`);\n  p.outro(\"Done\");\n}\n\nasync function copyToClipboard(text: string): Promise<void> {\n  const platform = process.platform;\n\n  try {\n    if (platform === \"darwin\") {\n      await execAsync(`echo -n ${JSON.stringify(text)} | pbcopy`);\n    } else if (platform === \"linux\") {\n      // Try xclip first, fall back to xsel\n      try {\n        await execAsync(`echo -n ${JSON.stringify(text)} | xclip -selection clipboard`);\n      } catch {\n        await execAsync(`echo -n ${JSON.stringify(text)} | xsel --clipboard --input`);\n      }\n    } else if (platform === \"win32\") {\n      await execAsync(`echo ${JSON.stringify(text)} | clip`);\n    } else {\n      throw new Error(`Unsupported platform: ${platform}`);\n    }\n  } catch (error) {\n    // Fallback: just tell the user the path\n    throw new Error(\n      `Could not copy to clipboard. Path: ${text}`\n    );\n  }\n}\n\nfunction formatRelativeTime(isoString: string): string {\n  const date = new Date(isoString);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMins / 60);\n  const diffDays = Math.floor(diffHours / 24);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 30) return `${diffDays}d ago`;\n\n  return date.toLocaleDateString(\"en-US\", {\n    year: \"numeric\",\n    month: \"short\",\n    day: \"numeric\",\n  });\n}\n","import { defineCommand, runMain } from \"citty\";\n\nconst main = defineCommand({\n  meta: {\n    name: \"clones\",\n    version: \"1.0.0\",\n    description:\n      \"A read-only Git repository manager for exploration and reference\",\n  },\n  subCommands: {\n    add: () => import(\"./commands/add.js\").then((m) => m.default),\n    list: () => import(\"./commands/list.js\").then((m) => m.default),\n    rm: () => import(\"./commands/rm.js\").then((m) => m.default),\n    sync: () => import(\"./commands/sync.js\").then((m) => m.default),\n  },\n  // Default: run interactive browser when no subcommand given\n  async run() {\n    const { default: browse } = await import(\"./commands/browse.js\");\n    await browse.run?.({ args: {} } as any);\n  },\n});\n\nrunMain(main);\n"],"mappings":";;;;;;;;;;;;AACA,OAAO,UAAU;AACjB,SAAS,qBAAqB;AAF9B;AAAA;AAAA;AAAA;AAAA;;;ACUO,SAAS,YAAY,KAA2B;AAErD,QAAM,IAAI,KAAK;AAGf,QAAM,WAAW,IAAI,MAAM,wCAAwC;AACnE,MAAI,UAAU;AACZ,UAAM,CAAC,EAAE,MAAM,OAAO,IAAI,IAAI;AAC9B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU,IAAI,SAAS,MAAM,IAAI,MAAM,GAAG,GAAG;AAAA,IAC/C;AAAA,EACF;AAGA,QAAM,aAAa,IAAI;AAAA,IACrB;AAAA,EACF;AACA,MAAI,YAAY;AACd,UAAM,CAAC,EAAE,MAAM,OAAO,IAAI,IAAI;AAC9B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU,IAAI,SAAS,MAAM,IAAI,MAAM,GAAG,GAAG;AAAA,IAC/C;AAAA,EACF;AAEA,QAAM,IAAI;AAAA,IACR,2BAA2B,GAAG;AAAA;AAAA,EAEhC;AACF;AAMO,SAAS,eAAe,QAA8B;AAC3D,SAAO,GAAG,OAAO,IAAI,IAAI,OAAO,KAAK,IAAI,OAAO,IAAI;AACtD;AApDA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,SAAS,eAAe;AACxB,SAAS,YAAY;AACrB,SAAS,aAAa;AAKf,SAAS,eAAuB;AACrC,SAAO,QAAQ,IAAI,cAAc,KAAK,QAAQ,GAAG,QAAQ;AAC3D;AAKO,SAAS,kBAA0B;AACxC,SAAO,KAAK,aAAa,GAAG,eAAe;AAC7C;AAKO,SAAS,YAAY,OAAe,MAAsB;AAC/D,SAAO,KAAK,aAAa,GAAG,OAAO,IAAI;AACzC;AAKA,eAAsB,kBAAiC;AACrD,QAAM,MAAM,aAAa;AACzB,QAAM,MAAM,KAAK,EAAE,WAAW,KAAK,CAAC;AACtC;AA/BA,IAoCa;AApCb;AAAA;AAAA;AAAA;AAoCO,IAAM,WAAW;AAAA,MACtB,gBAAgB;AAAA,MAChB,YAAY;AAAA,MACZ,KAAK;AAAA,MACL,mBAAmB;AAAA,IACrB;AAAA;AAAA;;;ACzCA,SAAS,UAAU,WAAW,cAAc;AAC5C,SAAS,kBAAkB;AAC3B,SAAS,SAAS,QAAAA,aAAY;AAC9B,SAAS,kBAAkB;AAOpB,SAAS,sBAAgC;AAC9C,SAAO;AAAA,IACL,SAAS;AAAA,IACT,cAAa,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC,OAAO,CAAC;AAAA,EACV;AACF;AAMA,eAAsB,eAAkC;AACtD,QAAMC,QAAO,gBAAgB;AAE7B,MAAI,CAAC,WAAWA,KAAI,GAAG;AACrB,WAAO,oBAAoB;AAAA,EAC7B;AAEA,MAAI;AACF,UAAM,UAAU,MAAM,SAASA,OAAM,OAAO;AAC5C,UAAM,OAAO,KAAK,MAAM,OAAO;AAG/B,QAAI,CAAC,KAAK,WAAW,CAAC,MAAM,QAAQ,KAAK,KAAK,GAAG;AAC/C,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AAEA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,QAAI,iBAAiB,aAAa;AAChC,YAAM,IAAI,MAAM,+BAA+BA,KAAI,EAAE;AAAA,IACvD;AACA,UAAM;AAAA,EACR;AACF;AAMA,eAAsB,cAAc,UAAmC;AACrE,QAAM,gBAAgB;AAEtB,QAAMA,QAAO,gBAAgB;AAC7B,QAAM,WAAWD,MAAK,QAAQC,KAAI,GAAG,aAAa,WAAW,CAAC,MAAM;AAGpE,WAAS,eAAc,oBAAI,KAAK,GAAE,YAAY;AAG9C,QAAM,UAAU,KAAK,UAAU,UAAU,MAAM,CAAC;AAChD,QAAM,UAAU,UAAU,SAAS,OAAO;AAG1C,QAAM,OAAO,UAAUA,KAAI;AAC7B;AAKO,SAAS,UAAU,UAAoB,IAAuC;AACnF,SAAO,SAAS,MAAM,KAAK,CAAC,UAAU,MAAM,OAAO,EAAE;AACvD;AAKO,SAAS,qBACd,UACA,OACA,MAC2B;AAC3B,SAAO,SAAS,MAAM;AAAA,IACpB,CAAC,UAAU,MAAM,UAAU,SAAS,MAAM,SAAS;AAAA,EACrD;AACF;AAMO,SAAS,SAAS,UAAoB,OAAgC;AAC3E,MAAI,UAAU,UAAU,MAAM,EAAE,GAAG;AACjC,UAAM,IAAI,MAAM,0CAA0C,MAAM,EAAE,EAAE;AAAA,EACtE;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO,CAAC,GAAG,SAAS,OAAO,KAAK;AAAA,EAClC;AACF;AAKO,SAAS,YACd,UACA,IACA,SACU;AACV,QAAM,QAAQ,SAAS,MAAM,UAAU,CAAC,UAAU,MAAM,OAAO,EAAE;AACjE,MAAI,UAAU,IAAI;AAChB,UAAM,IAAI,MAAM,qCAAqC,EAAE,EAAE;AAAA,EAC3D;AAEA,QAAM,eAAe,CAAC,GAAG,SAAS,KAAK;AACvC,eAAa,KAAK,IAAI,EAAE,GAAG,aAAa,KAAK,GAAG,GAAG,QAAQ;AAE3D,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO;AAAA,EACT;AACF;AAKO,SAAS,YAAY,UAAoB,IAAsB;AACpE,QAAM,WAAW,SAAS,MAAM,OAAO,CAAC,UAAU,MAAM,OAAO,EAAE;AAEjE,MAAI,SAAS,WAAW,SAAS,MAAM,QAAQ;AAC7C,UAAM,IAAI,MAAM,qCAAqC,EAAE,EAAE;AAAA,EAC3D;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO;AAAA,EACT;AACF;AAKO,SAAS,aACd,UACA,MACiB;AACjB,MAAI,KAAK,WAAW,EAAG,QAAO,SAAS;AAEvC,SAAO,SAAS,MAAM;AAAA,IAAO,CAAC,UAC5B,MAAM,MAAM,KAAK,CAAC,QAAQ,KAAK,SAAS,GAAG,CAAC;AAAA,EAC9C;AACF;AAMO,SAAS,gBACd,UACA,SACiB;AACjB,QAAM,CAAC,cAAc,WAAW,IAAI,QAAQ,MAAM,GAAG;AAErD,SAAO,SAAS,MAAM,OAAO,CAAC,UAAU;AACtC,UAAM,aACJ,iBAAiB,OAAO,MAAM,UAAU;AAC1C,UAAM,YACJ,CAAC,eAAe,gBAAgB,OAAO,MAAM,SAAS;AACxD,WAAO,cAAc;AAAA,EACvB,CAAC;AACH;AA5KA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;;;ACLA,SAAS,iBAAoD;AAC7D,SAAS,cAAAC,mBAAkB;AAC3B,SAAS,QAAAC,aAAY;AAMrB,eAAsB,UACpB,KACA,WACA,UAAmC,CAAC,GACrB;AACf,QAAM,MAAM,UAAU;AACtB,QAAM,aAAa,QAAQ,cAAc;AAEzC,QAAM,IAAI,MAAM,KAAK,WAAW,CAAC,YAAY,UAAU,CAAC;AAC1D;AAKA,eAAsB,eACpB,WACA,aAAqB,UACN;AACf,QAAM,MAAM,UAAU,SAAS;AAC/B,QAAM,IAAI,MAAM,YAAY,CAAC,SAAS,CAAC;AACzC;AAKA,eAAsB,UAAU,WAAoC;AAClE,QAAM,MAAM,UAAU,SAAS;AAG/B,QAAM,YAAY,MAAM,IAAI,IAAI,EAAE,UAAU,EAAE,CAAC;AAC/C,QAAM,aAAa,UAAU,QAAQ;AAGrC,QAAM,IAAI,MAAM,CAAC,UAAU,MAAM,CAAC;AAGlC,QAAM,WAAW,MAAM,IAAI,IAAI,EAAE,UAAU,EAAE,CAAC;AAC9C,QAAM,YAAY,SAAS,QAAQ;AAGnC,MAAI,cAAc,aAAa,eAAe,WAAW;AACvD,QAAI;AACF,YAAMC,OAAM,MAAM,IAAI,IAAI,EAAE,MAAM,YAAY,IAAI,UAAU,CAAC;AAC7D,aAAOA,KAAI;AAAA,IACb,QAAQ;AAEN,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAKA,eAAsB,gBAAgB,WAAoC;AACxE,QAAM,MAAM,UAAU,SAAS;AAE/B,QAAM,YAAY,MAAM,IAAI,IAAI,EAAE,UAAU,EAAE,CAAC;AAC/C,QAAM,aAAa,UAAU,QAAQ;AAErC,QAAM,IAAI,KAAK,CAAC,WAAW,CAAC;AAE5B,QAAM,WAAW,MAAM,IAAI,IAAI,EAAE,UAAU,EAAE,CAAC;AAC9C,QAAM,YAAY,SAAS,QAAQ;AAEnC,MAAI,cAAc,aAAa,eAAe,WAAW;AACvD,QAAI;AACF,YAAMA,OAAM,MAAM,IAAI,IAAI,EAAE,MAAM,YAAY,IAAI,UAAU,CAAC;AAC7D,aAAOA,KAAI;AAAA,IACb,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAKA,eAAsB,iBAAiB,WAAkC;AACvE,QAAM,MAAM,UAAU,SAAS;AAC/B,QAAM,IAAI,gBAAgB,CAAC,UAAU,aAAa,CAAC;AACrD;AAKA,eAAsB,cAAc,WAAwC;AAE1E,MAAI,CAACF,YAAW,SAAS,GAAG;AAC1B,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,eAAe;AAAA,MACf,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,SAAS;AAAA,IACX;AAAA,EACF;AAGA,MAAI,CAACA,YAAWC,MAAK,WAAW,MAAM,CAAC,GAAG;AACxC,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,eAAe;AAAA,MACf,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,SAAS;AAAA,IACX;AAAA,EACF;AAEA,QAAM,MAAM,UAAU,SAAS;AAE/B,MAAI;AACF,UAAM,SAAuB,MAAM,IAAI,OAAO;AAE9C,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,eAAe,OAAO;AAAA,MACtB,YAAY,OAAO;AAAA,MACnB,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO;AAAA,MACf,SAAS,OAAO,MAAM,SAAS;AAAA,IACjC;AAAA,EACF,SAAS,OAAO;AAEd,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,eAAe;AAAA,MACf,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,SAAS;AAAA,IACX;AAAA,EACF;AACF;AAKA,eAAsB,aACpB,WACA,aAAqB,UACG;AACxB,QAAM,MAAM,UAAU,SAAS;AAE/B,MAAI;AACF,UAAM,UAAU,MAAM,IAAI,WAAW,IAAI;AACzC,UAAM,SAAS,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU;AACxD,WAAO,QAAQ,MAAM,SAAS;AAAA,EAChC,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,eAAsB,QAAQ,WAAqC;AACjE,QAAM,gBAAgBA,MAAK,WAAW,gBAAgB;AACtD,MAAI,CAACD,YAAW,aAAa,GAAG;AAC9B,WAAO;AAAA,EACT;AAEA,MAAI;AACF,UAAM,EAAE,UAAAG,UAAS,IAAI,MAAM,OAAO,aAAkB;AACpD,UAAM,UAAU,MAAMA,UAAS,eAAe,OAAO;AACrD,WAAO,QAAQ,SAAS,YAAY;AAAA,EACtC,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,eAAsB,QACpB,WACA,aAAqB,UACN;AACf,QAAM,MAAM,UAAU,SAAS;AAC/B,QAAM,IAAI,IAAI,CAAC,OAAO,QAAQ,UAAU,CAAC;AAC3C;AA1MA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA,SAAS,qBAAqB;AAC9B,YAAY,OAAO;AADnB,IAQO;AARP;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAGA,IAAO,cAAQ,cAAc;AAAA,MAC3B,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,MAAM;AAAA,QACJ,KAAK;AAAA,UACH,MAAM;AAAA,UACN,aAAa;AAAA,UACb,UAAU;AAAA,QACZ;AAAA,QACA,MAAM;AAAA,UACJ,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,aAAa;AAAA,UACX,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,mBAAmB;AAAA,UACjB,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,YAAY;AAAA,UACV,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,KAAK;AAAA,UACH,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,MACF;AAAA,MACA,MAAM,IAAI,EAAE,KAAK,GAAG;AAClB,QAAE,QAAM,YAAY;AAEpB,YAAI,iBAAiB;AACrB,cAAM,IAAM,UAAQ;AAEpB,YAAI;AAEF,gBAAM,SAAS,YAAY,KAAK,GAAG;AACnC,gBAAM,SAAS,eAAe,MAAM;AACpC,gBAAM,YAAY,YAAY,OAAO,OAAO,OAAO,IAAI;AAEvD,UAAE,MAAI,KAAK,eAAe,OAAO,KAAK,IAAI,OAAO,IAAI,EAAE;AACvD,UAAE,MAAI,KAAK,SAAS,OAAO,IAAI,EAAE;AAGjC,gBAAM,WAAW,MAAM,aAAa;AAGpC,cAAI,UAAU,UAAU,MAAM,GAAG;AAC/B,YAAE,MAAI,MAAM,0CAA0C,MAAM,EAAE;AAC9D,YAAE,MAAI,KAAK,oEAAoE;AAC/E,oBAAQ,KAAK,CAAC;AAAA,UAChB;AAGA,gBAAM,SAAS,MAAM,cAAc,SAAS;AAC5C,cAAI,OAAO,QAAQ;AACjB,YAAE,MAAI,MAAM,mCAAmC,SAAS,EAAE;AAC1D,YAAE,MAAI,KAAK,2DAA2D;AACtE,oBAAQ,KAAK,CAAC;AAAA,UAChB;AAGA,gBAAM,gBAAgB;AAGtB,YAAE,MAAM,WAAW,OAAO,KAAK,IAAI,OAAO,IAAI,KAAK;AACnD,2BAAiB;AACjB,gBAAM,UAAU,OAAO,UAAU,SAAS;AAC1C,YAAE,KAAK,aAAa,SAAS,EAAE;AAG/B,gBAAM,OAAO,KAAK,OACd,KAAK,KAAK,MAAM,GAAG,EAAE,IAAI,CAAC,MAAc,EAAE,KAAK,CAAC,IAChD;AAEJ,gBAAM,iBACJ,KAAK,iBAAiB,MAAM,YAAY,YAAY,SAAS;AAE/D,gBAAM,aACJ,KAAK,eAAe,cAAc,cAAc,SAAS;AAE3D,gBAAM,MACJ,KAAK,QAAQ,WACT,WACA,KAAK,QAAQ,UACb,UACA,SAAS;AAGf,gBAAM,QAAuB;AAAA,YAC3B,IAAI;AAAA,YACJ,MAAM,OAAO;AAAA,YACb,OAAO,OAAO;AAAA,YACd,MAAM,OAAO;AAAA,YACb,UAAU,OAAO;AAAA,YACjB,aAAa,KAAK;AAAA,YAClB;AAAA,YACA,mBAAmB,SAAS;AAAA,YAC5B;AAAA,YACA;AAAA,YACA;AAAA,YACA,UAAS,oBAAI,KAAK,GAAE,YAAY;AAAA,YAChC,SAAS;AAAA,YACT,eAAc,oBAAI,KAAK,GAAE,YAAY;AAAA,YACrC,SAAS;AAAA,UACX;AAGA,gBAAM,kBAAkB,SAAS,UAAU,KAAK;AAChD,gBAAM,cAAc,eAAe;AAEnC,UAAE,MAAI,QAAQ,SAAS,OAAO,KAAK,IAAI,OAAO,IAAI,cAAc;AAEhE,cAAI,QAAQ,KAAK,SAAS,GAAG;AAC3B,YAAE,MAAI,KAAK,SAAS,KAAK,KAAK,IAAI,CAAC,EAAE;AAAA,UACvC;AAEA,UAAE,QAAM,OAAO;AAAA,QACjB,SAAS,OAAO;AACd,cAAI,gBAAgB;AAClB,cAAE,KAAK,QAAQ;AAAA,UACjB;AACA,UAAE,MAAI,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAClE,kBAAQ,KAAK,CAAC;AAAA,QAChB;AAAA,MACF;AAAA,IACF,CAAC;AAAA;AAAA;;;AC1ID;AAAA;AAAA;AAAA;AAAA,SAAS,iBAAAC,sBAAqB;AAC9B,YAAYC,QAAO;AAsFnB,SAAS,WAAW,OAAyB;AAC3C,QAAM,SAAS;AAAA,IACb,SAAS;AAAA,IACT,OAAO,MAAM,IAAI,CAAC,EAAE,OAAO,QAAQ,UAAU,OAAO;AAAA,MAClD,IAAI,MAAM;AAAA,MACV,OAAO,MAAM;AAAA,MACb,MAAM,MAAM;AAAA,MACZ;AAAA,MACA,UAAU,MAAM;AAAA,MAChB,QAAQ,OAAO;AAAA,MACf,UAAU,OAAO;AAAA,MACjB,aAAa,OAAO;AAAA,MACpB,YAAY,OAAO;AAAA,MACnB,SAAS,OAAO;AAAA,MAChB,YAAY,OAAO;AAAA,MACnB,aAAa,CAAC,CAAC,OAAO;AAAA,MACtB,QAAQ,OAAO;AAAA,MACf,WAAW,OAAO;AAAA,MAClB,cAAc,MAAM;AAAA,MACpB,MAAM,MAAM;AAAA,MACZ,aAAa,MAAM;AAAA,IACrB,EAAE;AAAA,EACJ;AAEA,UAAQ,IAAI,KAAK,UAAU,QAAQ,MAAM,CAAC,CAAC;AAC7C;AAEA,SAAS,aAAa,OAAmB,aAA2B;AAClE,QAAM,YAAY,aAAa;AAC/B,QAAM,WAAW,UAAU,QAAQ,QAAQ,IAAI,QAAQ,IAAI,GAAG;AAE9D,UAAQ,IAAI;AACZ,UAAQ;AAAA,IACN,oBAAoB,MAAM,MAAM,wBAAwB,WAAW,WAAW,CAAC;AAAA,EACjF;AACA,UAAQ,IAAI;AAEZ,aAAW,EAAE,OAAO,QAAQ,UAAU,KAAK,OAAO;AAChD,UAAM,YAAY,UAAU,QAAQ,QAAQ,IAAI,QAAQ,IAAI,GAAG;AAE/D,YAAQ,IAAI,GAAG,MAAM,KAAK,IAAI,MAAM,IAAI,EAAE;AAC1C,YAAQ,IAAI,WAAW,SAAS,EAAE;AAClC,YAAQ,IAAI,UAAU,MAAM,QAAQ,EAAE;AAEtC,QAAI,MAAM,QAAQ,MAAM,KAAK,SAAS,GAAG;AACvC,cAAQ,IAAI,WAAW,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE;AAAA,IAChD;AAEA,QAAI,MAAM,aAAa;AACrB,cAAQ,IAAI,kBAAkB,MAAM,WAAW,EAAE;AAAA,IACnD;AAGA,QAAI,CAAC,OAAO,QAAQ;AAClB,cAAQ,IAAI,uCAAuC;AAAA,IACrD,WAAW,CAAC,OAAO,WAAW;AAC5B,cAAQ,IAAI,uCAAuC;AAAA,IACrD,WAAW,OAAO,YAAY;AAC5B,cAAQ,IAAI,2BAA2B;AACvC,cAAQ,IAAI,gCAAgC;AAAA,IAC9C,WAAW,CAAC,OAAO,UAAU;AAC3B,cAAQ,IAAI,aAAa,OAAO,aAAa,gBAAgB;AAC7D,cAAQ,IAAI,uCAAuC;AAAA,IACrD,OAAO;AACL,YAAM,aAAa,cAAc,QAAQ,MAAM,YAAY;AAC3D,cAAQ,IAAI,aAAa,OAAO,aAAa,WAAW,OAAO,QAAQ,EAAE;AACzE,cAAQ,IAAI,aAAa,UAAU,EAAE;AAAA,IACvC;AAEA,YAAQ,IAAI;AAAA,EACd;AACF;AAEA,SAAS,cAAc,QAAoB,cAA+B;AACxE,QAAM,QAAkB,CAAC;AAEzB,MAAI,OAAO,SAAS;AAClB,UAAM,KAAK,cAAc;AAAA,EAC3B;AAEA,MAAI,OAAO,SAAS,GAAG;AACrB,UAAM,KAAK,GAAG,OAAO,MAAM,SAAS;AAAA,EACtC;AAEA,MAAI,OAAO,QAAQ,GAAG;AACpB,UAAM,KAAK,GAAG,OAAO,KAAK,QAAQ;AAAA,EACpC;AAEA,MAAI,MAAM,WAAW,GAAG;AACtB,UAAM,KAAK,cAAc;AAAA,EAC3B;AAEA,MAAI,cAAc;AAChB,UAAM,KAAK,WAAW,mBAAmB,YAAY,CAAC,GAAG;AAAA,EAC3D;AAEA,SAAO,MAAM,KAAK,IAAI;AACxB;AAEA,SAAS,WAAW,WAA2B;AAC7C,QAAM,OAAO,IAAI,KAAK,SAAS;AAC/B,SAAO,KAAK,mBAAmB,SAAS;AAAA,IACtC,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,EACV,CAAC;AACH;AAEA,SAAS,mBAAmB,WAA2B;AACrD,QAAM,OAAO,IAAI,KAAK,SAAS;AAC/B,QAAM,MAAM,oBAAI,KAAK;AACrB,QAAM,SAAS,IAAI,QAAQ,IAAI,KAAK,QAAQ;AAC5C,QAAM,WAAW,KAAK,MAAM,SAAS,GAAK;AAC1C,QAAM,YAAY,KAAK,MAAM,WAAW,EAAE;AAC1C,QAAM,WAAW,KAAK,MAAM,YAAY,EAAE;AAE1C,MAAI,WAAW,EAAG,QAAO;AACzB,MAAI,WAAW,GAAI,QAAO,GAAG,QAAQ;AACrC,MAAI,YAAY,GAAI,QAAO,GAAG,SAAS;AACvC,MAAI,WAAW,GAAI,QAAO,GAAG,QAAQ;AACrC,SAAO,WAAW,SAAS;AAC7B;AAlNA,IAaO;AAbP;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AASA,IAAO,eAAQD,eAAc;AAAA,MAC3B,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,MAAM;AAAA,QACJ,MAAM;AAAA,UACJ,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,MAAM;AAAA,UACJ,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,MACF;AAAA,MACA,MAAM,IAAI,EAAE,KAAK,GAAG;AAClB,cAAM,WAAW,MAAM,aAAa;AAEpC,YAAI,SAAS,MAAM,WAAW,GAAG;AAC/B,cAAI,KAAK,MAAM;AACb,oBAAQ,IAAI,KAAK,UAAU,EAAE,SAAS,SAAS,OAAO,CAAC,EAAE,GAAG,MAAM,CAAC,CAAC;AAAA,UACtE,OAAO;AACL,YAAE,OAAI,KAAK,8BAA8B;AACzC,YAAE,OAAI,KAAK,6CAA6C;AAAA,UAC1D;AACA;AAAA,QACF;AAGA,YAAI,QAAQ,SAAS;AAErB,YAAI,KAAK,MAAM;AACb,gBAAM,OAAO,KAAK,KAAK,MAAM,GAAG,EAAE,IAAI,CAAC,MAAc,EAAE,KAAK,CAAC;AAC7D,kBAAQ,aAAa,UAAU,IAAI;AAAA,QACrC;AAEA,YAAI,KAAK,QAAQ;AACf,gBAAM,WAAW;AAAA,YACf,EAAE,GAAG,UAAU,MAAM;AAAA,YACrB,KAAK;AAAA,UACP;AACA,kBAAQ;AAAA,QACV;AAEA,YAAI,MAAM,WAAW,GAAG;AACtB,cAAI,KAAK,MAAM;AACb,oBAAQ,IAAI,KAAK,UAAU,EAAE,SAAS,SAAS,OAAO,CAAC,EAAE,GAAG,MAAM,CAAC,CAAC;AAAA,UACtE,OAAO;AACL,YAAE,OAAI,KAAK,mCAAmC;AAAA,UAChD;AACA;AAAA,QACF;AAGA,cAAM,QAAoB,MAAM,QAAQ;AAAA,UACtC,MAAM,IAAI,OAAO,UAAU;AACzB,kBAAM,YAAY,YAAY,MAAM,OAAO,MAAM,IAAI;AACrD,kBAAM,SAAS,MAAM,cAAc,SAAS;AAC5C,mBAAO,EAAE,OAAO,QAAQ,UAAU;AAAA,UACpC,CAAC;AAAA,QACH;AAEA,YAAI,KAAK,MAAM;AACb,qBAAW,KAAK;AAAA,QAClB,OAAO;AACL,uBAAa,OAAO,SAAS,WAAW;AAAA,QAC1C;AAAA,MACF;AAAA,IACF,CAAC;AAAA;AAAA;;;ACrFD;AAAA;AAAA;AAAA;AAAA,SAAS,iBAAAE,sBAAqB;AAC9B,YAAYC,QAAO;AACnB,SAAS,UAAU;AACnB,SAAS,cAAAC,mBAAkB;AAH3B,IAOO;AAPP;AAAA;AAAA;AAAA;AAIA;AACA;AAEA,IAAO,aAAQF,eAAc;AAAA,MAC3B,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,MAAM;AAAA,QACJ,MAAM;AAAA,UACJ,MAAM;AAAA,UACN,aAAa;AAAA,UACb,UAAU;AAAA,QACZ;AAAA,QACA,aAAa;AAAA,UACX,MAAM;AAAA,UACN,aAAa;AAAA,UACb,SAAS;AAAA,QACX;AAAA,QACA,KAAK;AAAA,UACH,MAAM;AAAA,UACN,OAAO;AAAA,UACP,aAAa;AAAA,UACb,SAAS;AAAA,QACX;AAAA,MACF;AAAA,MACA,MAAM,IAAI,EAAE,KAAK,GAAG;AAClB,QAAE,SAAM,WAAW;AAGnB,cAAM,QAAQ,KAAK,KAAK,MAAM,GAAG;AACjC,YAAI,MAAM,WAAW,GAAG;AACtB,UAAE,OAAI,MAAM,mBAAmB,KAAK,IAAI,EAAE;AAC1C,UAAE,OAAI,KAAK,6BAA6B;AACxC,kBAAQ,KAAK,CAAC;AAAA,QAChB;AAEA,cAAM,CAAC,OAAO,IAAI,IAAI;AAGtB,cAAM,WAAW,MAAM,aAAa;AAGpC,cAAM,QAAQ,qBAAqB,UAAU,OAAO,IAAI;AAExD,YAAI,CAAC,OAAO;AACV,UAAE,OAAI,MAAM,qCAAqC,KAAK,IAAI,IAAI,EAAE;AAChE,UAAE,OAAI,KAAK,oDAAoD;AAC/D,kBAAQ,KAAK,CAAC;AAAA,QAChB;AAGA,cAAM,YAAY,YAAY,OAAO,IAAI;AACzC,cAAM,aAAaE,YAAW,SAAS;AAGvC,QAAE,OAAI,KAAK,eAAe,KAAK,IAAI,IAAI,EAAE;AACzC,QAAE,OAAI,KAAK,gBAAgB,MAAM,EAAE,EAAE;AACrC,QAAE,OAAI,KAAK,eAAe,SAAS,EAAE;AACrC,QAAE,OAAI,KAAK,YAAY,aAAa,QAAQ,sBAAsB,EAAE;AAGpE,cAAM,yBAAyB;AAC/B,cAAM,qBAAqB,cAAc,CAAC,KAAK,WAAW;AAE1D,QAAE,OAAI,KAAK,uBAAuB;AAClC,QAAE,OAAI,QAAQ,gCAA2B;AACzC,YAAI,oBAAoB;AACtB,UAAE,OAAI,QAAQ,kCAA6B;AAAA,QAC7C,WAAW,cAAc,KAAK,WAAW,GAAG;AAC1C,UAAE,OAAI,QAAQ,8CAAyC;AAAA,QACzD,WAAW,CAAC,YAAY;AACtB,UAAE,OAAI,QAAQ,yCAAoC;AAAA,QACpD;AAGA,YAAI,CAAC,KAAK,KAAK;AACb,gBAAM,UAAU,qBACZ,UAAU,KAAK,IAAI,IAAI,yCACvB,UAAU,KAAK,IAAI,IAAI;AAE3B,gBAAM,iBAAiB,MAAQ,WAAQ;AAAA,YACrC;AAAA,UACF,CAAC;AAED,cAAM,YAAS,cAAc,KAAK,CAAC,gBAAgB;AACjD,YAAE,SAAM,WAAW;AACnB;AAAA,UACF;AAAA,QACF;AAGA,YAAI,oBAAoB;AACtB,gBAAM,IAAM,WAAQ;AACpB,YAAE,MAAM,YAAY,SAAS,KAAK;AAElC,cAAI;AACF,kBAAM,GAAG,WAAW,EAAE,WAAW,MAAM,OAAO,KAAK,CAAC;AACpD,cAAE,KAAK,WAAW,SAAS,EAAE;AAAA,UAC/B,SAAS,OAAO;AACd,cAAE,KAAK,4BAA4B;AACnC,YAAE,OAAI,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAClE,YAAE,OAAI,KAAK,8DAA8D;AACzE,oBAAQ,KAAK,CAAC;AAAA,UAChB;AAAA,QACF;AAGA,YAAI;AACF,gBAAM,kBAAkB,YAAY,UAAU,MAAM,EAAE;AACtD,gBAAM,cAAc,eAAe;AACnC,UAAE,OAAI,QAAQ,WAAW,KAAK,IAAI,IAAI,gBAAgB;AAAA,QACxD,SAAS,OAAO;AACd,UAAE,OAAI,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAClE,kBAAQ,KAAK,CAAC;AAAA,QAChB;AAEA,QAAE,SAAM,OAAO;AAAA,MACjB;AAAA,IACF,CAAC;AAAA;AAAA;;;AC3HD,SAAS,SAAS,MAAM,aAAa;AACrC,SAAS,QAAAC,aAAY;AACrB,SAAS,cAAAC,mBAAkB;AAwB3B,eAAe,UAAUC,OAAgC;AACvD,MAAI;AACF,UAAM,QAAQ,MAAM,MAAMA,KAAI;AAC9B,WAAO,MAAM,eAAe;AAAA,EAC9B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,eAAe,YAAYA,OAAgC;AACzD,MAAI;AACF,UAAM,QAAQ,MAAM,KAAKA,KAAI;AAC7B,WAAO,MAAM,YAAY;AAAA,EAC3B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAMA,eAAsB,gBAAqC;AACzD,QAAM,YAAY,aAAa;AAC/B,QAAM,aAA+B,CAAC;AACtC,QAAM,UAA8C,CAAC;AAGrD,MAAI,CAACD,YAAW,SAAS,GAAG;AAC1B,WAAO,EAAE,YAAY,QAAQ;AAAA,EAC/B;AAGA,MAAI;AACJ,MAAI;AACF,gBAAY,MAAM,QAAQ,SAAS;AAAA,EACrC,SAAS,OAAO;AACd,YAAQ,KAAK;AAAA,MACX,MAAM;AAAA,MACN,QAAQ,0BAA0B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,IAC1F,CAAC;AACD,WAAO,EAAE,YAAY,QAAQ;AAAA,EAC/B;AAEA,aAAW,SAAS,WAAW;AAE7B,QAAI,MAAM,WAAW,GAAG,KAAK,UAAU,iBAAiB;AACtD;AAAA,IACF;AAEA,UAAM,YAAYD,MAAK,WAAW,KAAK;AAGvC,QAAI,MAAM,UAAU,SAAS,GAAG;AAC9B,cAAQ,KAAK,EAAE,MAAM,WAAW,QAAQ,oBAAoB,CAAC;AAC7D;AAAA,IACF;AAGA,QAAI,CAAE,MAAM,YAAY,SAAS,GAAI;AACnC;AAAA,IACF;AAGA,QAAI;AACJ,QAAI;AACF,iBAAW,MAAM,QAAQ,SAAS;AAAA,IACpC,SAAS,OAAO;AACd,cAAQ,KAAK;AAAA,QACX,MAAM;AAAA,QACN,QAAQ,0BAA0B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,MAC1F,CAAC;AACD;AAAA,IACF;AAEA,eAAW,QAAQ,UAAU;AAE3B,UAAI,KAAK,WAAW,GAAG,GAAG;AACxB;AAAA,MACF;AAEA,YAAM,WAAWA,MAAK,WAAW,IAAI;AAGrC,UAAI,MAAM,UAAU,QAAQ,GAAG;AAC7B,gBAAQ,KAAK,EAAE,MAAM,UAAU,QAAQ,oBAAoB,CAAC;AAC5D;AAAA,MACF;AAGA,UAAI,CAAE,MAAM,YAAY,QAAQ,GAAI;AAClC;AAAA,MACF;AAGA,YAAM,UAAUA,MAAK,UAAU,MAAM;AACrC,YAAM,SAASC,YAAW,OAAO;AAEjC,UAAI,CAAC,QAAQ;AACX,gBAAQ,KAAK,EAAE,MAAM,UAAU,QAAQ,oBAAoB,CAAC;AAC5D;AAAA,MACF;AAEA,iBAAW,KAAK;AAAA,QACd;AAAA,QACA;AAAA,QACA,WAAW;AAAA,QACX,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO,EAAE,YAAY,QAAQ;AAC/B;AAOA,eAAsB,aAAa,WAAqC;AACtE,QAAM,UAAUD,MAAK,WAAW,MAAM;AAEtC,MAAI;AACF,UAAM,QAAQ,MAAM,MAAM,OAAO;AAGjC,QAAI,MAAM,OAAO,GAAG;AAClB,aAAO;AAAA,IACT;AAIA,UAAM,YAAY,aAAa;AAC/B,QAAI,UAAU;AAEd,WAAO,YAAY,aAAa,YAAY,KAAK;AAC/C,YAAM,SAASA,MAAK,SAAS,IAAI;AACjC,YAAM,YAAYA,MAAK,QAAQ,MAAM;AAErC,UAAIC,YAAW,SAAS,KAAK,WAAW,WAAW;AAEjD,eAAO;AAAA,MACT;AAEA,gBAAU;AAAA,IACZ;AAEA,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AArLA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;ACHA;AAAA;AAAA;AAAA;AAAA,SAAS,iBAAAE,sBAAqB;AAC9B,YAAYC,QAAO;AAgMnB,eAAe,WACb,UACA,SACsB;AACtB,QAAM,UAA6C,CAAC;AACpD,MAAI,kBAAkB;AAEtB,QAAM,EAAE,WAAW,IAAI,MAAM,cAAc;AAE3C,aAAW,QAAQ,YAAY;AAE7B,UAAM,WAAW,SAAS,MAAM;AAAA,MAC9B,CAAC,MAAM,EAAE,UAAU,KAAK,SAAS,EAAE,SAAS,KAAK;AAAA,IACnD;AAEA,QAAI,UAAU;AACZ;AAAA,IACF;AAGA,QAAI,MAAM,aAAa,KAAK,SAAS,GAAG;AACtC;AAAA,IACF;AAGA,UAAM,YAAY,MAAM,aAAa,KAAK,SAAS;AACnD,QAAI,CAAC,WAAW;AACd;AAAA,IACF;AAGA,QAAI;AACJ,QAAI;AACF,eAAS,YAAY,SAAS;AAAA,IAChC,QAAQ;AACN;AAAA,IACF;AAEA,UAAM,SAAS,eAAe,MAAM;AAGpC,QAAI,UAAU,iBAAiB,MAAM,GAAG;AACtC;AAAA,IACF;AAEA,QAAI,CAAC,QAAQ,QAAQ;AACnB,YAAM,QAAuB;AAAA,QAC3B,IAAI;AAAA,QACJ,MAAM,OAAO;AAAA,QACb,OAAO,OAAO;AAAA,QACd,MAAM,OAAO;AAAA,QACb,UAAU,OAAO;AAAA,QACjB,mBAAmB,SAAS;AAAA,QAC5B,gBAAgB,SAAS;AAAA,QACzB,YAAY,SAAS;AAAA,QACrB,KAAK,SAAS;AAAA,QACd,UAAS,oBAAI,KAAK,GAAE,YAAY;AAAA,QAChC,SAAS;AAAA,QACT,SAAS;AAAA,MACX;AAEA,wBAAkB,SAAS,iBAAiB,KAAK;AAAA,IACnD;AAEA,YAAQ,KAAK,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,KAAK,CAAC;AACnD,IAAE,OAAI,KAAK,OAAO,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE;AAAA,EAC7C;AAEA,SAAO,EAAE,SAAS,UAAU,gBAAgB;AAC9C;AAWA,eAAe,WACb,UACA,SACsB;AACtB,QAAM,SAA4C,CAAC;AACnD,QAAM,SAA4C,CAAC;AAEnD,aAAW,SAAS,SAAS,OAAO;AAClC,QAAI,CAAC,MAAM,QAAS;AAEpB,UAAM,YAAY,YAAY,MAAM,OAAO,MAAM,IAAI;AACrD,UAAM,SAAS,MAAM,cAAc,SAAS;AAE5C,QAAI,OAAO,UAAU,OAAO,WAAW;AACrC;AAAA,IACF;AAEA,UAAM,OAAO,GAAG,MAAM,KAAK,IAAI,MAAM,IAAI;AAEzC,QAAI,QAAQ,QAAQ;AAClB,MAAE,OAAI,KAAK,OAAO,IAAI,gBAAgB;AACtC,aAAO,KAAK,EAAE,OAAO,MAAM,OAAO,MAAM,MAAM,KAAK,CAAC;AACpD;AAAA,IACF;AAGA,UAAM,IAAM,WAAQ;AACpB,MAAE,MAAM,aAAa,IAAI,KAAK;AAE9B,QAAI;AACF,YAAM,UAAU,MAAM,UAAU,WAAW;AAAA,QACzC,YAAY,MAAM;AAAA,MACpB,CAAC;AACD,QAAE,KAAK,OAAO,IAAI,WAAW;AAC7B,aAAO,KAAK,EAAE,OAAO,MAAM,OAAO,MAAM,MAAM,KAAK,CAAC;AAAA,IACtD,SAAS,OAAO;AACd,QAAE,KAAK,YAAO,IAAI,iBAAiB;AACnC,aAAO,KAAK;AAAA,QACV;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO,EAAE,QAAQ,OAAO;AAC1B;AAMA,eAAe,WACb,OACA,SACuB;AACvB,QAAM,YAAY,YAAY,MAAM,OAAO,MAAM,IAAI;AACrD,QAAM,WAAW,GAAG,MAAM,KAAK,IAAI,MAAM,IAAI;AAG7C,QAAM,SAAS,MAAM,cAAc,SAAS;AAE5C,MAAI,CAAC,OAAO,QAAQ;AAClB,IAAE,OAAI,MAAM,YAAO,QAAQ,YAAY;AACvC,WAAO,EAAE,QAAQ,WAAW,QAAQ,oBAAoB;AAAA,EAC1D;AAEA,MAAI,CAAC,OAAO,WAAW;AACrB,IAAE,OAAI,MAAM,YAAO,QAAQ,mBAAmB;AAC9C,WAAO,EAAE,QAAQ,WAAW,QAAQ,iBAAiB;AAAA,EACvD;AAEA,MAAI,OAAO,YAAY;AACrB,IAAE,OAAI,KAAK,YAAO,QAAQ,kBAAkB;AAC5C,WAAO,EAAE,QAAQ,WAAW,QAAQ,gBAAgB;AAAA,EACtD;AAEA,MAAI,CAAC,OAAO,UAAU;AACpB,IAAE,OAAI,KAAK,YAAO,QAAQ,gBAAgB;AAC1C,WAAO,EAAE,QAAQ,WAAW,QAAQ,uBAAuB;AAAA,EAC7D;AAEA,MAAI,OAAO,WAAW,CAAC,QAAQ,OAAO;AACpC,IAAE,OAAI,KAAK,YAAO,QAAQ,uBAAuB;AACjD,WAAO,EAAE,QAAQ,WAAW,QAAQ,qBAAqB;AAAA,EAC3D;AAEA,MAAI,QAAQ,QAAQ;AAClB,IAAE,OAAI,KAAK,YAAO,QAAQ,iBAAiB;AAC3C,WAAO,EAAE,QAAQ,WAAW,SAAS,EAAE;AAAA,EACzC;AAEA,MAAI;AAEF,UAAM,IAAM,WAAQ;AACpB,MAAE,MAAM,KAAK,QAAQ,eAAe;AACpC,UAAM,eAAe,WAAW,MAAM,iBAAiB;AAGvD,QAAI,UAAU;AACd,QAAI,MAAM,mBAAmB,cAAc;AACzC,gBAAU,MAAM,UAAU,SAAS;AACnC,QAAE,KAAK,YAAO,QAAQ,UAAU,UAAU,IAAI,KAAK,OAAO,aAAa,EAAE,GAAG;AAAA,IAC9E,OAAO;AACL,gBAAU,MAAM,gBAAgB,SAAS;AACzC,QAAE,KAAK,YAAO,QAAQ,YAAY,UAAU,IAAI,KAAK,OAAO,aAAa,EAAE,GAAG;AAAA,IAChF;AAGA,QAAI,MAAM,eAAe,aAAa;AACpC,UAAI;AACF,cAAM,iBAAiB,SAAS;AAAA,MAClC,QAAQ;AAAA,MAER;AAAA,IACF;AAGA,QAAI,MAAM,QAAQ,YAAa,MAAM,QAAQ,UAAW,MAAM,QAAQ,SAAS,GAAK;AAClF,UAAI;AACF,cAAM,QAAQ,WAAW,MAAM,iBAAiB;AAAA,MAClD,QAAQ;AAAA,MAER;AAAA,IACF;AAEA,WAAO,EAAE,QAAQ,WAAW,QAAQ;AAAA,EACtC,SAAS,OAAO;AACd,UAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACrE,IAAE,OAAI,MAAM,YAAO,QAAQ,KAAK,OAAO,EAAE;AACzC,WAAO,EAAE,QAAQ,SAAS,OAAO,QAAQ;AAAA,EAC3C;AACF;AAMA,SAAS,aAAa,WAA4B,QAAuB;AACvE,QAAM,UAAU,UAAU,OAAO,CAAC,MAAM,EAAE,WAAW,SAAS,EAAE;AAChE,QAAM,SAAS,UAAU,OAAO,CAAC,MAAM,EAAE,WAAW,QAAQ,EAAE;AAC9D,QAAM,UAAU,UAAU,OAAO,CAAC,MAAM,EAAE,WAAW,SAAS,EAAE;AAChE,QAAM,UAAU,UAAU,OAAO,CAAC,MAAM,EAAE,WAAW,SAAS,EAAE;AAChE,QAAM,SAAS,UAAU,OAAO,CAAC,MAAM,EAAE,WAAW,OAAO,EAAE;AAE7D,UAAQ,IAAI,SAAI,OAAO,EAAE,CAAC;AAE1B,MAAI,QAAQ;AACV,YAAQ,IAAI,QAAQ;AAAA,EACtB;AAEA,QAAM,QAAkB,CAAC;AACzB,MAAI,UAAU,EAAG,OAAM,KAAK,GAAG,OAAO,UAAU;AAChD,MAAI,SAAS,EAAG,OAAM,KAAK,GAAG,MAAM,SAAS;AAC7C,MAAI,UAAU,EAAG,OAAM,KAAK,GAAG,OAAO,UAAU;AAChD,MAAI,UAAU,EAAG,OAAM,KAAK,GAAG,OAAO,UAAU;AAChD,MAAI,SAAS,EAAG,OAAM,KAAK,GAAG,MAAM,SAAS;AAE7C,MAAI,MAAM,WAAW,GAAG;AACtB,YAAQ,IAAI,gBAAgB;AAAA,EAC9B,OAAO;AACL,YAAQ,IAAI,MAAM,KAAK,IAAI,CAAC;AAAA,EAC9B;AACF;AAnbA,IAgCO;AAhCP;AAAA;AAAA;AAAA;AAEA;AAQA;AAWA;AACA;AACA;AASA,IAAO,eAAQD,eAAc;AAAA,MAC3B,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,MAAM;AAAA,QACJ,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,WAAW;AAAA,UACT,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,QACA,OAAO;AAAA,UACL,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,MACF;AAAA,MACA,MAAM,IAAI,EAAE,KAAK,GAAG;AAClB,QAAE,SAAM,aAAa;AAErB,cAAM,SAAS,KAAK,SAAS,KAAK;AAClC,cAAM,QAAQ,KAAK,SAAS;AAE5B,YAAI,QAAQ;AACV,UAAE,OAAI,KAAK,wCAAwC;AAAA,QACrD;AAEA,YAAI,WAAW,MAAM,aAAa;AAClC,cAAM,YAA6B,CAAC;AAKpC,QAAE,OAAI,KAAK,yCAAyC;AAEpD,cAAM,EAAE,SAAS,UAAU,mBAAmB,IAAI,MAAM;AAAA,UACtD;AAAA,UACA,EAAE,OAAO;AAAA,QACX;AACA,mBAAW;AAEX,mBAAW,QAAQ,SAAS;AAC1B,oBAAU,KAAK;AAAA,YACb,MAAM,GAAG,KAAK,KAAK,IAAI,KAAK,IAAI;AAAA,YAChC,QAAQ;AAAA,UACV,CAAC;AAAA,QACH;AAEA,YAAI,QAAQ,WAAW,GAAG;AACxB,UAAE,OAAI,KAAK,4BAA4B;AAAA,QACzC,OAAO;AACL,UAAE,OAAI,QAAQ,KAAK,QAAQ,MAAM,YAAY,SAAS,aAAa,EAAE,UAAU;AAAA,QACjF;AAKA,QAAE,OAAI,KAAK,mCAAmC;AAE9C,cAAM,EAAE,QAAQ,QAAQ,YAAY,IAAI,MAAM,WAAW,UAAU,EAAE,OAAO,CAAC;AAE7E,mBAAW,QAAQ,QAAQ;AACzB,oBAAU,KAAK;AAAA,YACb,MAAM,GAAG,KAAK,KAAK,IAAI,KAAK,IAAI;AAAA,YAChC,QAAQ;AAAA,UACV,CAAC;AAAA,QACH;AAEA,mBAAW,OAAO,aAAa;AAC7B,oBAAU,KAAK;AAAA,YACb,MAAM,IAAI;AAAA,YACV,QAAQ;AAAA,YACR,QAAQ,IAAI;AAAA,UACd,CAAC;AAAA,QACH;AAEA,YAAI,OAAO,WAAW,KAAK,YAAY,WAAW,GAAG;AACnD,UAAE,OAAI,KAAK,6BAA6B;AAAA,QAC1C,OAAO;AACL,cAAI,OAAO,SAAS,GAAG;AACrB,YAAE,OAAI,QAAQ,KAAK,OAAO,MAAM,YAAY,SAAS,aAAa,EAAE,SAAS;AAAA,UAC/E;AACA,cAAI,YAAY,SAAS,GAAG;AAC1B,YAAE,OAAI,MAAM,KAAK,YAAY,MAAM,iBAAiB;AAAA,UACtD;AAAA,QACF;AAKA,QAAE,OAAI,KAAK,4BAA4B;AAGvC,YAAI,gBAAgB,SAAS,MAAM,OAAO,CAAC,MAAM,EAAE,OAAO;AAE1D,YAAI,KAAK,QAAQ;AACf,0BAAgB,gBAAgB,EAAE,GAAG,UAAU,OAAO,cAAc,GAAG,KAAK,MAAM;AAClF,UAAE,OAAI,KAAK,mBAAmB,KAAK,MAAM,EAAE;AAAA,QAC7C;AAEA,YAAI,cAAc,WAAW,GAAG;AAC9B,UAAE,OAAI,KAAK,sBAAsB;AAAA,QACnC,OAAO;AACL,qBAAW,SAAS,eAAe;AACjC,kBAAM,SAAS,MAAM,WAAW,OAAO,EAAE,QAAQ,MAAM,CAAC;AACxD,kBAAM,OAAO,GAAG,MAAM,KAAK,IAAI,MAAM,IAAI;AAEzC,gBAAI,OAAO,WAAW,WAAW;AAC/B,wBAAU,KAAK;AAAA,gBACb;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ,OAAO,UAAU,GAAG,OAAO,OAAO,aAAa;AAAA,cACzD,CAAC;AAGD,kBAAI,CAAC,QAAQ;AACX,2BAAW,YAAY,UAAU,MAAM,IAAI;AAAA,kBACzC,eAAc,oBAAI,KAAK,GAAE,YAAY;AAAA,gBACvC,CAAC;AAAA,cACH;AAAA,YACF,WAAW,OAAO,WAAW,WAAW;AACtC,wBAAU,KAAK;AAAA,gBACb;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ,OAAO;AAAA,cACjB,CAAC;AAAA,YACH,OAAO;AACL,wBAAU,KAAK;AAAA,gBACb;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ,OAAO;AAAA,cACjB,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAKA,YAAI,CAAC,QAAQ;AACX,gBAAM,cAAc,QAAQ;AAAA,QAC9B;AAEA,gBAAQ,IAAI;AACZ,qBAAa,WAAW,MAAM;AAE9B,QAAE,SAAM,OAAO;AAAA,MACjB;AAAA,IACF,CAAC;AAAA;AAAA;;;ACtLD;AAAA;AAAA;AAAA;AAAA,SAAS,iBAAAE,sBAAqB;AAC9B,YAAYC,QAAO;AACnB,SAAS,YAAY;AACrB,SAAS,iBAAiB;AAuF1B,eAAe,gBACb,MACA,UACe;AACf,QAAM,YAAY,KAAK,UAAU,QAAQ,QAAQ,IAAI,QAAQ,IAAI,GAAG;AAGpE,UAAQ,IAAI;AACZ,UAAQ,IAAI,KAAK,KAAK,MAAM,KAAK,IAAI,KAAK,MAAM,IAAI,EAAE;AACtD,UAAQ,IAAI,KAAK,SAAI,OAAO,EAAE,CAAC,EAAE;AACjC,UAAQ,IAAI,WAAW,SAAS,EAAE;AAClC,UAAQ,IAAI,WAAW,KAAK,MAAM,QAAQ,EAAE;AAE5C,MAAI,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAK,SAAS,GAAG;AACjD,YAAQ,IAAI,WAAW,KAAK,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE;AAAA,EACrD,OAAO;AACL,YAAQ,IAAI,gBAAgB;AAAA,EAC9B;AAEA,MAAI,KAAK,MAAM,aAAa;AAC1B,YAAQ,IAAI,WAAW,KAAK,MAAM,WAAW,EAAE;AAAA,EACjD,OAAO;AACL,YAAQ,IAAI,gBAAgB;AAAA,EAC9B;AAGA,MAAI,CAAC,KAAK,OAAO,QAAQ;AACvB,YAAQ,IAAI,0BAAqB;AAAA,EACnC,WAAW,CAAC,KAAK,OAAO,WAAW;AACjC,YAAQ,IAAI,iCAA4B;AAAA,EAC1C,WAAW,KAAK,OAAO,SAAS;AAC9B,YAAQ,IAAI,wBAAmB;AAAA,EACjC,OAAO;AACL,YAAQ,IAAI,wBAAmB;AAAA,EACjC;AAEA,MAAI,KAAK,MAAM,cAAc;AAC3B,YAAQ,IAAI,aAAaC,oBAAmB,KAAK,MAAM,YAAY,CAAC,EAAE;AAAA,EACxE;AAEA,UAAQ,IAAI;AAGZ,QAAM,SAAS,MAAQ,UAAO;AAAA,IAC5B,SAAS;AAAA,IACT,SAAS;AAAA,MACP,EAAE,OAAO,QAAQ,OAAO,yBAAyB;AAAA,MACjD,EAAE,OAAO,aAAa,OAAO,YAAY;AAAA,MACzC,EAAE,OAAO,aAAa,OAAO,mBAAmB;AAAA,MAChD,EAAE,OAAO,QAAQ,OAAO,eAAe;AAAA,IACzC;AAAA,EACF,CAAC;AAED,MAAM,YAAS,MAAM,GAAG;AACtB,IAAE,SAAM,MAAM;AACd;AAAA,EACF;AAEA,UAAQ,QAAQ;AAAA,IACd,KAAK;AACH,YAAM,gBAAgB,KAAK,SAAS;AACpC,MAAE,OAAI,QAAQ,WAAW,KAAK,SAAS,EAAE;AACzC,MAAE,SAAM,MAAM;AACd;AAAA,IAEF,KAAK;AACH,YAAM,SAAS,MAAM,QAAQ;AAC7B;AAAA,IAEF,KAAK;AACH,YAAM,gBAAgB,MAAM,QAAQ;AACpC;AAAA,IAEF,KAAK;AAEH,YAAM,EAAE,SAAS,cAAc,IAAI,MAAM;AACzC,YAAM,cAAc,MAAM,EAAE,MAAM,CAAC,EAAE,CAAQ;AAC7C;AAAA,EACJ;AACF;AAEA,eAAe,SACb,MACA,UACe;AACf,QAAM,cAAc,KAAK,MAAM,MAAM,KAAK,IAAI,KAAK;AAEnD,QAAM,UAAU,MAAQ,QAAK;AAAA,IAC3B,SAAS;AAAA,IACT,cAAc;AAAA,IACd,aAAa;AAAA,EACf,CAAC;AAED,MAAM,YAAS,OAAO,GAAG;AACvB,IAAE,SAAM,WAAW;AACnB;AAAA,EACF;AAEA,QAAM,OAAO,UACT,QACG,MAAM,GAAG,EACT,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,EACnB,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,IAC7B;AAEJ,QAAM,kBAAkB,YAAY,UAAU,KAAK,MAAM,IAAI,EAAE,KAAK,CAAC;AACrE,QAAM,cAAc,eAAe;AAEnC,EAAE,OAAI,QAAQ,oBAAoB,KAAK,MAAM,KAAK,IAAI,KAAK,MAAM,IAAI,EAAE;AACvE,EAAE,SAAM,MAAM;AAChB;AAEA,eAAe,gBACb,MACA,UACe;AACf,QAAM,UAAU,MAAQ,QAAK;AAAA,IAC3B,SAAS;AAAA,IACT,cAAc,KAAK,MAAM,eAAe;AAAA,IACxC,aAAa;AAAA,EACf,CAAC;AAED,MAAM,YAAS,OAAO,GAAG;AACvB,IAAE,SAAM,WAAW;AACnB;AAAA,EACF;AAEA,QAAM,cAAc,WAAW;AAE/B,QAAM,kBAAkB,YAAY,UAAU,KAAK,MAAM,IAAI,EAAE,YAAY,CAAC;AAC5E,QAAM,cAAc,eAAe;AAEnC,EAAE,OAAI,QAAQ,2BAA2B,KAAK,MAAM,KAAK,IAAI,KAAK,MAAM,IAAI,EAAE;AAC9E,EAAE,SAAM,MAAM;AAChB;AAEA,eAAe,gBAAgBC,OAA6B;AAC1D,QAAM,WAAW,QAAQ;AAEzB,MAAI;AACF,QAAI,aAAa,UAAU;AACzB,YAAM,UAAU,WAAW,KAAK,UAAUA,KAAI,CAAC,WAAW;AAAA,IAC5D,WAAW,aAAa,SAAS;AAE/B,UAAI;AACF,cAAM,UAAU,WAAW,KAAK,UAAUA,KAAI,CAAC,+BAA+B;AAAA,MAChF,QAAQ;AACN,cAAM,UAAU,WAAW,KAAK,UAAUA,KAAI,CAAC,6BAA6B;AAAA,MAC9E;AAAA,IACF,WAAW,aAAa,SAAS;AAC/B,YAAM,UAAU,QAAQ,KAAK,UAAUA,KAAI,CAAC,SAAS;AAAA,IACvD,OAAO;AACL,YAAM,IAAI,MAAM,yBAAyB,QAAQ,EAAE;AAAA,IACrD;AAAA,EACF,SAAS,OAAO;AAEd,UAAM,IAAI;AAAA,MACR,sCAAsCA,KAAI;AAAA,IAC5C;AAAA,EACF;AACF;AAEA,SAASD,oBAAmB,WAA2B;AACrD,QAAM,OAAO,IAAI,KAAK,SAAS;AAC/B,QAAM,MAAM,oBAAI,KAAK;AACrB,QAAM,SAAS,IAAI,QAAQ,IAAI,KAAK,QAAQ;AAC5C,QAAM,WAAW,KAAK,MAAM,SAAS,GAAK;AAC1C,QAAM,YAAY,KAAK,MAAM,WAAW,EAAE;AAC1C,QAAM,WAAW,KAAK,MAAM,YAAY,EAAE;AAE1C,MAAI,WAAW,EAAG,QAAO;AACzB,MAAI,WAAW,GAAI,QAAO,GAAG,QAAQ;AACrC,MAAI,YAAY,GAAI,QAAO,GAAG,SAAS;AACvC,MAAI,WAAW,GAAI,QAAO,GAAG,QAAQ;AAErC,SAAO,KAAK,mBAAmB,SAAS;AAAA,IACtC,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK;AAAA,EACP,CAAC;AACH;AA9QA,IAaM,WAQC;AArBP;AAAA;AAAA;AAAA;AAIA;AAKA;AACA;AAGA,IAAM,YAAY,UAAU,IAAI;AAQhC,IAAO,iBAAQF,eAAc;AAAA,MAC3B,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,MAAM,CAAC;AAAA,MACP,MAAM,MAAM;AACV,QAAE,SAAM,QAAQ;AAEhB,cAAM,WAAW,MAAM,aAAa;AAEpC,YAAI,SAAS,MAAM,WAAW,GAAG;AAC/B,UAAE,OAAI,KAAK,8BAA8B;AACzC,UAAE,OAAI,KAAK,6CAA6C;AACxD,UAAE,SAAM,EAAE;AACV;AAAA,QACF;AAGA,cAAM,IAAM,WAAQ;AACpB,UAAE,MAAM,yBAAyB;AAEjC,cAAM,QAAoB,MAAM,QAAQ;AAAA,UACtC,SAAS,MAAM,IAAI,OAAO,UAAU;AAClC,kBAAM,YAAY,YAAY,MAAM,OAAO,MAAM,IAAI;AACrD,kBAAM,SAAS,MAAM,cAAc,SAAS;AAC5C,mBAAO,EAAE,OAAO,QAAQ,UAAU;AAAA,UACpC,CAAC;AAAA,QACH;AAEA,UAAE,KAAK,GAAG,MAAM,MAAM,sBAAsB;AAG5C,cAAM,UAAU,MAAM,IAAI,CAACI,UAAS;AAClC,gBAAM,OAAO,GAAGA,MAAK,MAAM,KAAK,IAAIA,MAAK,MAAM,IAAI;AACnD,gBAAM,QAAkB,CAAC;AAEzB,cAAIA,MAAK,MAAM,QAAQA,MAAK,MAAM,KAAK,SAAS,GAAG;AACjD,kBAAM,KAAKA,MAAK,MAAM,KAAK,KAAK,IAAI,CAAC;AAAA,UACvC;AACA,cAAI,CAACA,MAAK,OAAO,QAAQ;AACvB,kBAAM,KAAK,SAAS;AAAA,UACtB,WAAWA,MAAK,OAAO,SAAS;AAC9B,kBAAM,KAAK,OAAO;AAAA,UACpB;AAEA,iBAAO;AAAA,YACL,OAAOA;AAAA,YACP,OAAO;AAAA,YACP,MAAM,MAAM,SAAS,IAAI,MAAM,KAAK,QAAK,IAAI;AAAA,UAC/C;AAAA,QACF,CAAC;AAGD,cAAM,WAAW,MAAQ,UAAO;AAAA,UAC9B,SAAS;AAAA,UACT;AAAA,QACF,CAAC;AAED,YAAM,YAAS,QAAQ,GAAG;AACxB,UAAE,SAAM,WAAW;AACnB;AAAA,QACF;AAEA,cAAM,OAAO;AACb,cAAM,gBAAgB,MAAM,QAAQ;AAAA,MACtC;AAAA,IACF,CAAC;AAAA;AAAA;;;ACxFD;AAAA,SAAS,iBAAAC,gBAAe,eAAe;AAEvC,IAAM,OAAOA,eAAc;AAAA,EACzB,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,SAAS;AAAA,IACT,aACE;AAAA,EACJ;AAAA,EACA,aAAa;AAAA,IACX,KAAK,MAAM,wDAA4B,KAAK,CAAC,MAAM,EAAE,OAAO;AAAA,IAC5D,MAAM,MAAM,0DAA6B,KAAK,CAAC,MAAM,EAAE,OAAO;AAAA,IAC9D,IAAI,MAAM,sDAA2B,KAAK,CAAC,MAAM,EAAE,OAAO;AAAA,IAC1D,MAAM,MAAM,0DAA6B,KAAK,CAAC,MAAM,EAAE,OAAO;AAAA,EAChE;AAAA;AAAA,EAEA,MAAM,MAAM;AACV,UAAM,EAAE,SAAS,OAAO,IAAI,MAAM;AAClC,UAAM,OAAO,MAAM,EAAE,MAAM,CAAC,EAAE,CAAQ;AAAA,EACxC;AACF,CAAC;AAED,QAAQ,IAAI;","names":["join","path","existsSync","join","log","readFile","defineCommand","p","defineCommand","p","existsSync","join","existsSync","path","defineCommand","p","defineCommand","p","formatRelativeTime","text","repo","defineCommand"]}