{"version":3,"sources":["../node_modules/tsup/assets/esm_shims.js","../src/lib/url-parser.ts","../src/lib/config.ts","../src/lib/registry.ts","../src/lib/git.ts","../src/commands/add.ts","../src/commands/list.ts","../src/commands/update.ts","../src/cli.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import type { ParsedGitUrl } from \"../types/index.js\";\n\n/**\n * Parse a Git URL (SSH or HTTPS) into its components\n *\n * Supports:\n * - SSH: git@github.com:owner/repo.git\n * - HTTPS: https://github.com/owner/repo.git\n * - HTTPS without .git: https://github.com/owner/repo\n */\nexport function parseGitUrl(url: string): ParsedGitUrl {\n  // Normalize: trim whitespace\n  url = url.trim();\n\n  // SSH format: git@host:owner/repo.git\n  const sshMatch = url.match(/^git@([^:]+):([^/]+)\\/(.+?)(?:\\.git)?$/);\n  if (sshMatch) {\n    const [, host, owner, repo] = sshMatch;\n    return {\n      host,\n      owner,\n      repo,\n      cloneUrl: url.endsWith(\".git\") ? url : `${url}.git`,\n    };\n  }\n\n  // HTTPS format: https://host/owner/repo.git\n  const httpsMatch = url.match(\n    /^https?:\\/\\/([^/]+)\\/([^/]+)\\/(.+?)(?:\\.git)?$/\n  );\n  if (httpsMatch) {\n    const [, host, owner, repo] = httpsMatch;\n    return {\n      host,\n      owner,\n      repo,\n      cloneUrl: url.endsWith(\".git\") ? url : `${url}.git`,\n    };\n  }\n\n  throw new Error(\n    `Invalid Git URL format: ${url}\\n` +\n      `Expected SSH (git@host:owner/repo.git) or HTTPS (https://host/owner/repo.git)`\n  );\n}\n\n/**\n * Generate a unique ID for a repository\n * Format: host:owner/repo\n */\nexport function generateRepoId(parsed: ParsedGitUrl): string {\n  return `${parsed.host}:${parsed.owner}/${parsed.repo}`;\n}\n\n/**\n * Validate that a string looks like a Git URL\n */\nexport function isValidGitUrl(url: string): boolean {\n  try {\n    parseGitUrl(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { homedir } from \"node:os\";\nimport { join } from \"node:path\";\nimport { mkdir } from \"node:fs/promises\";\n\n/**\n * Get the clones directory from environment or default to ~/Clones\n */\nexport function getClonesDir(): string {\n  return process.env.CLONES_DIR || join(homedir(), \"Clones\");\n}\n\n/**\n * Get the path to registry.json\n */\nexport function getRegistryPath(): string {\n  return join(getClonesDir(), \"registry.json\");\n}\n\n/**\n * Get the local path for a repository based on owner/repo\n */\nexport function getRepoPath(owner: string, repo: string): string {\n  return join(getClonesDir(), owner, repo);\n}\n\n/**\n * Ensure the clones directory exists\n */\nexport async function ensureClonesDir(): Promise<void> {\n  const dir = getClonesDir();\n  await mkdir(dir, { recursive: true });\n}\n\n/**\n * Default values for new registry entries\n */\nexport const DEFAULTS = {\n  updateStrategy: \"hard-reset\" as const,\n  submodules: \"none\" as const,\n  lfs: \"auto\" as const,\n  defaultRemoteName: \"origin\",\n};\n","import { readFile, writeFile, rename } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { dirname, join } from \"node:path\";\nimport { randomUUID } from \"node:crypto\";\nimport type { Registry, RegistryEntry } from \"../types/index.js\";\nimport { getRegistryPath, ensureClonesDir } from \"./config.js\";\n\n/**\n * Create an empty registry\n */\nexport function createEmptyRegistry(): Registry {\n  return {\n    version: \"1.0.0\",\n    lastUpdated: new Date().toISOString(),\n    repos: [],\n  };\n}\n\n/**\n * Read the registry from disk\n * Returns an empty registry if the file doesn't exist\n */\nexport async function readRegistry(): Promise<Registry> {\n  const path = getRegistryPath();\n\n  if (!existsSync(path)) {\n    return createEmptyRegistry();\n  }\n\n  try {\n    const content = await readFile(path, \"utf-8\");\n    const data = JSON.parse(content) as Registry;\n\n    // Validate basic structure\n    if (!data.version || !Array.isArray(data.repos)) {\n      throw new Error(\"Invalid registry format\");\n    }\n\n    return data;\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      throw new Error(`Registry file is corrupted: ${path}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Write the registry to disk atomically\n * Uses write-to-temp + rename pattern to prevent corruption\n */\nexport async function writeRegistry(registry: Registry): Promise<void> {\n  await ensureClonesDir();\n\n  const path = getRegistryPath();\n  const tempPath = join(dirname(path), `.registry.${randomUUID()}.tmp`);\n\n  // Update timestamp\n  registry.lastUpdated = new Date().toISOString();\n\n  // Write to temp file\n  const content = JSON.stringify(registry, null, 2);\n  await writeFile(tempPath, content, \"utf-8\");\n\n  // Atomic rename\n  await rename(tempPath, path);\n}\n\n/**\n * Find a registry entry by ID\n */\nexport function findEntry(registry: Registry, id: string): RegistryEntry | undefined {\n  return registry.repos.find((entry) => entry.id === id);\n}\n\n/**\n * Find a registry entry by owner/repo\n */\nexport function findEntryByOwnerRepo(\n  registry: Registry,\n  owner: string,\n  repo: string\n): RegistryEntry | undefined {\n  return registry.repos.find(\n    (entry) => entry.owner === owner && entry.repo === repo\n  );\n}\n\n/**\n * Add an entry to the registry\n * Throws if an entry with the same ID already exists\n */\nexport function addEntry(registry: Registry, entry: RegistryEntry): Registry {\n  if (findEntry(registry, entry.id)) {\n    throw new Error(`Repository already exists in registry: ${entry.id}`);\n  }\n\n  return {\n    ...registry,\n    repos: [...registry.repos, entry],\n  };\n}\n\n/**\n * Update an entry in the registry\n */\nexport function updateEntry(\n  registry: Registry,\n  id: string,\n  updates: Partial<RegistryEntry>\n): Registry {\n  const index = registry.repos.findIndex((entry) => entry.id === id);\n  if (index === -1) {\n    throw new Error(`Repository not found in registry: ${id}`);\n  }\n\n  const updatedRepos = [...registry.repos];\n  updatedRepos[index] = { ...updatedRepos[index], ...updates };\n\n  return {\n    ...registry,\n    repos: updatedRepos,\n  };\n}\n\n/**\n * Remove an entry from the registry\n */\nexport function removeEntry(registry: Registry, id: string): Registry {\n  const filtered = registry.repos.filter((entry) => entry.id !== id);\n\n  if (filtered.length === registry.repos.length) {\n    throw new Error(`Repository not found in registry: ${id}`);\n  }\n\n  return {\n    ...registry,\n    repos: filtered,\n  };\n}\n\n/**\n * Filter entries by tags (any match)\n */\nexport function filterByTags(\n  registry: Registry,\n  tags: string[]\n): RegistryEntry[] {\n  if (tags.length === 0) return registry.repos;\n\n  return registry.repos.filter((entry) =>\n    entry.tags?.some((tag) => tags.includes(tag))\n  );\n}\n\n/**\n * Filter entries by owner/repo pattern (supports wildcards)\n * Pattern format: \"owner/repo\" or \"owner/\\*\" or \"\\*\\/repo\"\n */\nexport function filterByPattern(\n  registry: Registry,\n  pattern: string\n): RegistryEntry[] {\n  const [ownerPattern, repoPattern] = pattern.split(\"/\");\n\n  return registry.repos.filter((entry) => {\n    const ownerMatch =\n      ownerPattern === \"*\" || entry.owner === ownerPattern;\n    const repoMatch =\n      !repoPattern || repoPattern === \"*\" || entry.repo === repoPattern;\n    return ownerMatch && repoMatch;\n  });\n}\n","import { simpleGit, type SimpleGit, type StatusResult } from \"simple-git\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport type { RepoStatus } from \"../types/index.js\";\n\n/**\n * Clone a repository to a local path\n */\nexport async function cloneRepo(\n  url: string,\n  localPath: string,\n  options: { remoteName?: string } = {}\n): Promise<void> {\n  const git = simpleGit();\n  const remoteName = options.remoteName || \"origin\";\n\n  await git.clone(url, localPath, [\"--origin\", remoteName]);\n}\n\n/**\n * Fetch from remote with prune\n */\nexport async function fetchWithPrune(\n  localPath: string,\n  remoteName: string = \"origin\"\n): Promise<void> {\n  const git = simpleGit(localPath);\n  await git.fetch(remoteName, [\"--prune\"]);\n}\n\n/**\n * Reset to upstream tracking branch (hard reset)\n */\nexport async function resetHard(localPath: string): Promise<number> {\n  const git = simpleGit(localPath);\n\n  // Get current position before reset\n  const beforeLog = await git.log({ maxCount: 1 });\n  const beforeHash = beforeLog.latest?.hash;\n\n  // Reset to upstream\n  await git.reset([\"--hard\", \"@{u}\"]);\n\n  // Get new position after reset\n  const afterLog = await git.log({ maxCount: 1 });\n  const afterHash = afterLog.latest?.hash;\n\n  // Count commits between old and new position\n  if (beforeHash && afterHash && beforeHash !== afterHash) {\n    try {\n      const log = await git.log({ from: beforeHash, to: afterHash });\n      return log.total;\n    } catch {\n      // If we can't count (e.g., history rewrite), return -1\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Pull with fast-forward only\n */\nexport async function pullFastForward(localPath: string): Promise<number> {\n  const git = simpleGit(localPath);\n\n  const beforeLog = await git.log({ maxCount: 1 });\n  const beforeHash = beforeLog.latest?.hash;\n\n  await git.pull([\"--ff-only\"]);\n\n  const afterLog = await git.log({ maxCount: 1 });\n  const afterHash = afterLog.latest?.hash;\n\n  if (beforeHash && afterHash && beforeHash !== afterHash) {\n    try {\n      const log = await git.log({ from: beforeHash, to: afterHash });\n      return log.total;\n    } catch {\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Update submodules recursively\n */\nexport async function updateSubmodules(localPath: string): Promise<void> {\n  const git = simpleGit(localPath);\n  await git.submoduleUpdate([\"--init\", \"--recursive\"]);\n}\n\n/**\n * Get the status of a local repository\n */\nexport async function getRepoStatus(localPath: string): Promise<RepoStatus> {\n  // Check if directory exists\n  if (!existsSync(localPath)) {\n    return {\n      exists: false,\n      isGitRepo: false,\n      currentBranch: null,\n      isDetached: false,\n      tracking: null,\n      ahead: 0,\n      behind: 0,\n      isDirty: false,\n    };\n  }\n\n  // Check if it's a git repo\n  if (!existsSync(join(localPath, \".git\"))) {\n    return {\n      exists: true,\n      isGitRepo: false,\n      currentBranch: null,\n      isDetached: false,\n      tracking: null,\n      ahead: 0,\n      behind: 0,\n      isDirty: false,\n    };\n  }\n\n  const git = simpleGit(localPath);\n\n  try {\n    const status: StatusResult = await git.status();\n\n    return {\n      exists: true,\n      isGitRepo: true,\n      currentBranch: status.current,\n      isDetached: status.detached,\n      tracking: status.tracking,\n      ahead: status.ahead,\n      behind: status.behind,\n      isDirty: status.files.length > 0,\n    };\n  } catch (error) {\n    // Corrupted git repo\n    return {\n      exists: true,\n      isGitRepo: false,\n      currentBranch: null,\n      isDetached: false,\n      tracking: null,\n      ahead: 0,\n      behind: 0,\n      isDirty: false,\n    };\n  }\n}\n\n/**\n * Get the remote URL for a repository\n */\nexport async function getRemoteUrl(\n  localPath: string,\n  remoteName: string = \"origin\"\n): Promise<string | null> {\n  const git = simpleGit(localPath);\n\n  try {\n    const remotes = await git.getRemotes(true);\n    const remote = remotes.find((r) => r.name === remoteName);\n    return remote?.refs?.fetch || null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check if a repository uses LFS (by checking .gitattributes)\n */\nexport async function usesLfs(localPath: string): Promise<boolean> {\n  const gitattributes = join(localPath, \".gitattributes\");\n  if (!existsSync(gitattributes)) {\n    return false;\n  }\n\n  try {\n    const { readFile } = await import(\"node:fs/promises\");\n    const content = await readFile(gitattributes, \"utf-8\");\n    return content.includes(\"filter=lfs\");\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Pull LFS objects\n */\nexport async function pullLfs(\n  localPath: string,\n  remoteName: string = \"origin\"\n): Promise<void> {\n  const git = simpleGit(localPath);\n  await git.raw([\"lfs\", \"pull\", remoteName]);\n}\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport { parseGitUrl, generateRepoId } from \"../lib/url-parser.js\";\nimport { readRegistry, writeRegistry, addEntry, findEntry } from \"../lib/registry.js\";\nimport { cloneRepo, getRepoStatus } from \"../lib/git.js\";\nimport { getRepoPath, DEFAULTS, ensureClonesDir } from \"../lib/config.js\";\nimport type { RegistryEntry } from \"../types/index.js\";\n\nexport default defineCommand({\n  meta: {\n    name: \"add\",\n    description: \"Add a new clone by Git URL\",\n  },\n  args: {\n    url: {\n      type: \"positional\",\n      description: \"Git URL (HTTPS or SSH)\",\n      required: true,\n    },\n    tags: {\n      type: \"string\",\n      description: \"Comma-separated tags\",\n    },\n    description: {\n      type: \"string\",\n      description: \"Human-readable description\",\n    },\n    \"update-strategy\": {\n      type: \"string\",\n      description: \"Update strategy: hard-reset (default) or ff-only\",\n    },\n    submodules: {\n      type: \"string\",\n      description: \"Submodule handling: none (default) or recursive\",\n    },\n    lfs: {\n      type: \"string\",\n      description: \"LFS handling: auto (default), always, or never\",\n    },\n  },\n  async run({ args }) {\n    p.intro(\"clones add\");\n\n    let spinnerStarted = false;\n    const s = p.spinner();\n\n    try {\n      // Parse the URL\n      const parsed = parseGitUrl(args.url);\n      const repoId = generateRepoId(parsed);\n      const localPath = getRepoPath(parsed.owner, parsed.repo);\n\n      p.log.info(`Repository: ${parsed.owner}/${parsed.repo}`);\n      p.log.info(`Host: ${parsed.host}`);\n\n      // Read current registry\n      const registry = await readRegistry();\n\n      // Check if already in registry\n      if (findEntry(registry, repoId)) {\n        p.log.error(`Repository already exists in registry: ${repoId}`);\n        p.log.info(\"Use 'clones update' to sync it, or 'clones rm' to remove it first.\");\n        process.exit(1);\n      }\n\n      // Check if local directory already exists\n      const status = await getRepoStatus(localPath);\n      if (status.exists) {\n        p.log.error(`Local directory already exists: ${localPath}`);\n        p.log.info(\"Use 'clones adopt' to add existing repos to the registry.\");\n        process.exit(1);\n      }\n\n      // Ensure clones directory exists\n      await ensureClonesDir();\n\n      // Clone the repository\n      s.start(`Cloning ${parsed.owner}/${parsed.repo}...`);\n      spinnerStarted = true;\n      await cloneRepo(parsed.cloneUrl, localPath);\n      s.stop(`Cloned to ${localPath}`);\n\n      // Parse options\n      const tags = args.tags\n        ? args.tags.split(\",\").map((t: string) => t.trim())\n        : undefined;\n\n      const updateStrategy =\n        args[\"update-strategy\"] === \"ff-only\" ? \"ff-only\" : DEFAULTS.updateStrategy;\n\n      const submodules =\n        args.submodules === \"recursive\" ? \"recursive\" : DEFAULTS.submodules;\n\n      const lfs =\n        args.lfs === \"always\"\n          ? \"always\"\n          : args.lfs === \"never\"\n          ? \"never\"\n          : DEFAULTS.lfs;\n\n      // Create registry entry\n      const entry: RegistryEntry = {\n        id: repoId,\n        host: parsed.host,\n        owner: parsed.owner,\n        repo: parsed.repo,\n        cloneUrl: parsed.cloneUrl,\n        description: args.description,\n        tags,\n        defaultRemoteName: DEFAULTS.defaultRemoteName,\n        updateStrategy,\n        submodules,\n        lfs,\n        addedAt: new Date().toISOString(),\n        addedBy: \"manual\",\n        lastSyncedAt: new Date().toISOString(),\n        managed: true,\n      };\n\n      // Add to registry\n      const updatedRegistry = addEntry(registry, entry);\n      await writeRegistry(updatedRegistry);\n\n      p.log.success(`Added ${parsed.owner}/${parsed.repo} to registry`);\n\n      if (tags && tags.length > 0) {\n        p.log.info(`Tags: ${tags.join(\", \")}`);\n      }\n\n      p.outro(\"Done!\");\n    } catch (error) {\n      if (spinnerStarted) {\n        s.stop(\"Failed\");\n      }\n      p.log.error(error instanceof Error ? error.message : String(error));\n      process.exit(1);\n    }\n  },\n});\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport { readRegistry, filterByTags, filterByPattern } from \"../lib/registry.js\";\nimport { getRepoStatus } from \"../lib/git.js\";\nimport { getRepoPath, getClonesDir } from \"../lib/config.js\";\nimport type { RegistryEntry, RepoStatus } from \"../types/index.js\";\n\ninterface ListItem {\n  entry: RegistryEntry;\n  status: RepoStatus;\n  localPath: string;\n}\n\nexport default defineCommand({\n  meta: {\n    name: \"list\",\n    description: \"List all tracked repositories\",\n  },\n  args: {\n    json: {\n      type: \"boolean\",\n      description: \"Output as JSON\",\n    },\n    tags: {\n      type: \"string\",\n      description: \"Filter by tags (comma-separated)\",\n    },\n    filter: {\n      type: \"string\",\n      description: \"Filter by owner/repo pattern (supports wildcards)\",\n    },\n  },\n  async run({ args }) {\n    const registry = await readRegistry();\n\n    if (registry.repos.length === 0) {\n      if (args.json) {\n        console.log(JSON.stringify({ version: \"1.0.0\", repos: [] }, null, 2));\n      } else {\n        p.log.info(\"No repositories in registry.\");\n        p.log.info(\"Use 'clones add <url>' to add a repository.\");\n      }\n      return;\n    }\n\n    // Apply filters\n    let repos = registry.repos;\n\n    if (args.tags) {\n      const tags = args.tags.split(\",\").map((t: string) => t.trim());\n      repos = filterByTags(registry, tags);\n    }\n\n    if (args.filter) {\n      const filtered = filterByPattern(\n        { ...registry, repos },\n        args.filter\n      );\n      repos = filtered;\n    }\n\n    if (repos.length === 0) {\n      if (args.json) {\n        console.log(JSON.stringify({ version: \"1.0.0\", repos: [] }, null, 2));\n      } else {\n        p.log.info(\"No repositories match the filter.\");\n      }\n      return;\n    }\n\n    // Gather status for each repo\n    const items: ListItem[] = await Promise.all(\n      repos.map(async (entry) => {\n        const localPath = getRepoPath(entry.owner, entry.repo);\n        const status = await getRepoStatus(localPath);\n        return { entry, status, localPath };\n      })\n    );\n\n    if (args.json) {\n      outputJson(items);\n    } else {\n      outputPretty(items, registry.lastUpdated);\n    }\n  },\n});\n\nfunction outputJson(items: ListItem[]): void {\n  const output = {\n    version: \"1.0.0\",\n    repos: items.map(({ entry, status, localPath }) => ({\n      id: entry.id,\n      owner: entry.owner,\n      repo: entry.repo,\n      localPath,\n      cloneUrl: entry.cloneUrl,\n      branch: status.currentBranch,\n      tracking: status.tracking,\n      behindCount: status.behind,\n      aheadCount: status.ahead,\n      isDirty: status.isDirty,\n      isDetached: status.isDetached,\n      hasUpstream: !!status.tracking,\n      exists: status.exists,\n      isGitRepo: status.isGitRepo,\n      lastSyncedAt: entry.lastSyncedAt,\n      tags: entry.tags,\n      description: entry.description,\n    })),\n  };\n\n  console.log(JSON.stringify(output, null, 2));\n}\n\nfunction outputPretty(items: ListItem[], lastUpdated: string): void {\n  const clonesDir = getClonesDir();\n  const shortDir = clonesDir.replace(process.env.HOME || \"\", \"~\");\n\n  console.log();\n  console.log(\n    `Clones Registry (${items.length} repos, last updated ${formatDate(lastUpdated)})`\n  );\n  console.log();\n\n  for (const { entry, status, localPath } of items) {\n    const shortPath = localPath.replace(process.env.HOME || \"\", \"~\");\n\n    console.log(`${entry.owner}/${entry.repo}`);\n    console.log(`  Path: ${shortPath}`);\n    console.log(`  URL: ${entry.cloneUrl}`);\n\n    if (entry.tags && entry.tags.length > 0) {\n      console.log(`  Tags: ${entry.tags.join(\", \")}`);\n    }\n\n    if (entry.description) {\n      console.log(`  Description: ${entry.description}`);\n    }\n\n    // Status line\n    if (!status.exists) {\n      console.log(`  Status: \\u2717 Missing (not cloned)`);\n    } else if (!status.isGitRepo) {\n      console.log(`  Status: \\u2717 Not a Git repository`);\n    } else if (status.isDetached) {\n      console.log(`  Branch: (detached HEAD)`);\n      console.log(`  Status: \\u26A0 Detached HEAD`);\n    } else if (!status.tracking) {\n      console.log(`  Branch: ${status.currentBranch} (no upstream)`);\n      console.log(`  Status: \\u26A0 No upstream tracking`);\n    } else {\n      const syncStatus = getSyncStatus(status, entry.lastSyncedAt);\n      console.log(`  Branch: ${status.currentBranch} \\u2192 ${status.tracking}`);\n      console.log(`  Status: ${syncStatus}`);\n    }\n\n    console.log();\n  }\n}\n\nfunction getSyncStatus(status: RepoStatus, lastSyncedAt?: string): string {\n  const parts: string[] = [];\n\n  if (status.isDirty) {\n    parts.push(\"\\u2717 Dirty\");\n  }\n\n  if (status.behind > 0) {\n    parts.push(`${status.behind} behind`);\n  }\n\n  if (status.ahead > 0) {\n    parts.push(`${status.ahead} ahead`);\n  }\n\n  if (parts.length === 0) {\n    parts.push(\"\\u2713 Clean\");\n  }\n\n  if (lastSyncedAt) {\n    parts.push(`(synced ${formatRelativeTime(lastSyncedAt)})`);\n  }\n\n  return parts.join(\", \");\n}\n\nfunction formatDate(isoString: string): string {\n  const date = new Date(isoString);\n  return date.toLocaleDateString(\"en-US\", {\n    year: \"numeric\",\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n  });\n}\n\nfunction formatRelativeTime(isoString: string): string {\n  const date = new Date(isoString);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMins / 60);\n  const diffDays = Math.floor(diffHours / 24);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 30) return `${diffDays}d ago`;\n  return formatDate(isoString);\n}\n","import { defineCommand } from \"citty\";\nimport * as p from \"@clack/prompts\";\nimport {\n  readRegistry,\n  writeRegistry,\n  updateEntry,\n  filterByPattern,\n} from \"../lib/registry.js\";\nimport {\n  fetchWithPrune,\n  resetHard,\n  pullFastForward,\n  getRepoStatus,\n  updateSubmodules,\n  usesLfs,\n  pullLfs,\n} from \"../lib/git.js\";\nimport { getRepoPath } from \"../lib/config.js\";\nimport type { RegistryEntry, UpdateResult } from \"../types/index.js\";\n\ninterface UpdateSummary {\n  entry: RegistryEntry;\n  result: UpdateResult;\n}\n\nexport default defineCommand({\n  meta: {\n    name: \"update\",\n    description: \"Sync all tracked repositories\",\n  },\n  args: {\n    filter: {\n      type: \"string\",\n      description: \"Filter by owner/repo pattern (supports wildcards)\",\n    },\n    \"dry-run\": {\n      type: \"boolean\",\n      description: \"Show what would be updated without making changes\",\n    },\n    force: {\n      type: \"boolean\",\n      description: \"Proceed even if working tree is dirty\",\n    },\n  },\n  async run({ args }) {\n    p.intro(\"clones update\");\n\n    let registry = await readRegistry();\n\n    if (registry.repos.length === 0) {\n      p.log.info(\"No repositories in registry.\");\n      p.log.info(\"Use 'clones add <url>' to add a repository.\");\n      p.outro(\"Done!\");\n      return;\n    }\n\n    // Apply filter\n    let repos = registry.repos.filter((r) => r.managed);\n\n    if (args.filter) {\n      repos = filterByPattern({ ...registry, repos }, args.filter);\n    }\n\n    if (repos.length === 0) {\n      p.log.info(\"No repositories match the filter.\");\n      p.outro(\"Done!\");\n      return;\n    }\n\n    const dryRun = args[\"dry-run\"] || false;\n    const force = args.force || false;\n\n    if (dryRun) {\n      p.log.warn(\"Dry run mode - no changes will be made\");\n    }\n\n    const summaries: UpdateSummary[] = [];\n\n    for (const entry of repos) {\n      const result = await updateRepo(entry, { dryRun, force });\n      summaries.push({ entry, result });\n\n      // Update registry with lastSyncedAt if successful\n      if (!dryRun && result.status === \"updated\") {\n        registry = updateEntry(registry, entry.id, {\n          lastSyncedAt: new Date().toISOString(),\n        });\n      }\n    }\n\n    // Save registry\n    if (!dryRun) {\n      await writeRegistry(registry);\n    }\n\n    // Print summary\n    console.log();\n    printSummary(summaries);\n\n    p.outro(\"Done!\");\n  },\n});\n\nasync function updateRepo(\n  entry: RegistryEntry,\n  options: { dryRun: boolean; force: boolean }\n): Promise<UpdateResult> {\n  const localPath = getRepoPath(entry.owner, entry.repo);\n  const repoName = `${entry.owner}/${entry.repo}`;\n\n  console.log();\n  console.log(repoName);\n\n  // Check status\n  const status = await getRepoStatus(localPath);\n\n  if (!status.exists) {\n    p.log.error(\"  \\u2717 SKIPPED (directory missing)\");\n    return { status: \"skipped\", reason: \"directory missing\" };\n  }\n\n  if (!status.isGitRepo) {\n    p.log.error(\"  \\u2717 SKIPPED (not a git repo)\");\n    return { status: \"skipped\", reason: \"not a git repo\" };\n  }\n\n  if (status.isDetached) {\n    p.log.error(\"  \\u2717 SKIPPED (detached HEAD)\");\n    return { status: \"skipped\", reason: \"detached HEAD\" };\n  }\n\n  if (!status.tracking) {\n    p.log.error(\"  \\u2717 SKIPPED (no upstream tracking)\");\n    return { status: \"skipped\", reason: \"no upstream tracking\" };\n  }\n\n  if (status.isDirty && !options.force) {\n    p.log.error(\"  \\u2717 SKIPPED (dirty working tree)\");\n    p.log.info(\"    Use --force to update anyway\");\n    return { status: \"skipped\", reason: \"dirty working tree\" };\n  }\n\n  if (options.dryRun) {\n    p.log.info(\"  \\u2713 Would fetch and reset\");\n    return { status: \"updated\", commits: 0 };\n  }\n\n  try {\n    // Fetch\n    const s = p.spinner();\n    s.start(\"  Fetching...\");\n    await fetchWithPrune(localPath, entry.defaultRemoteName);\n    s.stop(\"  Fetched\");\n\n    // Reset or pull based on strategy\n    let commits = 0;\n    if (entry.updateStrategy === \"hard-reset\") {\n      commits = await resetHard(localPath);\n      p.log.success(\n        `  \\u2713 Reset to ${status.tracking}${commits > 0 ? ` (${commits} commits)` : \"\"}`\n      );\n    } else {\n      commits = await pullFastForward(localPath);\n      p.log.success(\n        `  \\u2713 Pulled (ff-only)${commits > 0 ? ` (${commits} commits)` : \"\"}`\n      );\n    }\n\n    // Submodules\n    if (entry.submodules === \"recursive\") {\n      try {\n        await updateSubmodules(localPath);\n        p.log.info(\"  \\u2713 Submodules updated\");\n      } catch (error) {\n        p.log.warn(\"  \\u26A0 Submodule update failed\");\n      }\n    }\n\n    // LFS\n    if (entry.lfs === \"always\" || (entry.lfs === \"auto\" && (await usesLfs(localPath)))) {\n      try {\n        await pullLfs(localPath, entry.defaultRemoteName);\n        p.log.info(\"  \\u2713 LFS pulled\");\n      } catch (error) {\n        p.log.warn(\"  \\u26A0 LFS pull failed (is git-lfs installed?)\");\n      }\n    }\n\n    return { status: \"updated\", commits };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    p.log.error(`  \\u2717 ERROR: ${message}`);\n    return { status: \"error\", error: message };\n  }\n}\n\nfunction printSummary(summaries: UpdateSummary[]): void {\n  const updated = summaries.filter((s) => s.result.status === \"updated\").length;\n  const skipped = summaries.filter((s) => s.result.status === \"skipped\").length;\n  const errors = summaries.filter((s) => s.result.status === \"error\").length;\n\n  console.log(\"â”€\".repeat(40));\n  console.log(\n    `Result: ${updated} updated, ${skipped} skipped, ${errors} errors`\n  );\n}\n","import { defineCommand, runMain } from \"citty\";\n\nconst main = defineCommand({\n  meta: {\n    name: \"clones\",\n    version: \"1.0.0\",\n    description:\n      \"A read-only Git repository manager for exploration and reference\",\n  },\n  subCommands: {\n    add: () => import(\"./commands/add.js\").then((m) => m.default),\n    list: () => import(\"./commands/list.js\").then((m) => m.default),\n    update: () => import(\"./commands/update.js\").then((m) => m.default),\n  },\n});\n\nrunMain(main);\n"],"mappings":"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","names":["join","path","existsSync","join","log","readFile","defineCommand","p","defineCommand","p","defineCommand"]}